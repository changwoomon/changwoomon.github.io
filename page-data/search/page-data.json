{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"","fields":{"slug":"/BOJ_2224/"},"frontmatter":{"date":"July 12, 2021","title":"[백준] 2224_명제 증명","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 2224번: 명제 증명\r\n# https://www.acmicpc.net/problem/2224\r\n# 메모리/시간: 32084KB / 160ms\r\n\r\nimport sys\r\nfrom collections import defaultdict, deque\r\n\r\ninput = sys.stdin.readline\r\n\r\nN = int(input())\r\n\r\n_input = set(input().rstrip() for _ in range(N))\r\n\r\nproposition = defaultdict(list)\r\n\r\nfor x in _input:\r\n    P, Q = x.split(\" => \")\r\n    proposition[P].append(Q)\r\n\r\ndef bfs(x):\r\n    consequent = []\r\n    consequent_len = 0\r\n    queue = deque([x])\r\n    while queue:\r\n        z = queue.popleft()\r\n        if z in proposition.keys():\r\n            for v in proposition[z]:\r\n                if v not in consequent and v != x:\r\n                    consequent.append(v)\r\n                    queue.append(v)\r\n                    consequent_len += 1\r\n    return consequent, consequent_len\r\n\r\nanswer = defaultdict(list)\r\ncnt = 0\r\n\r\nfor k in proposition.keys():\r\n    consequent, consequent_len = bfs(k)\r\n    answer[k] = sorted(consequent)\r\n    cnt += consequent_len\r\n\r\nprint(cnt)\r\nfor k in sorted(proposition.keys()):\r\n    for x in answer[k]:\r\n        print(f\"{k} => {x}\")\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_11265/"},"frontmatter":{"date":"July 12, 2021","title":"[백준] 11265_끝나지 않는 파티","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 11265번: 끝나지 않는 파티\r\n# https://www.acmicpc.net/problem/11265\r\n# 메모리/시간: 127152KB / 500ms (PyPy3)\r\n\r\nimport sys\r\n\r\ninput = sys.stdin.readline\r\n\r\nN, M = map(int, input().split())\r\n\r\ngraph = [list(map(int, input().split())) for _ in range(N)]\r\n\r\nfor k in range(N):\r\n    for i in range(N):\r\n        for j in range(N):\r\n            graph[i][j] = min(graph[i][j], graph[i][k] + graph[k][j])\r\n\r\nfor _ in range(M):\r\n    A, B, C = map(int, input().split())\r\n    A, B = A - 1, B - 1\r\n    print(\"Enjoy other party\") if graph[A][B] <= C else print(\"Stay here\")\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_11403/"},"frontmatter":{"date":"July 09, 2021","title":"[백준] 11403_경로 찾기","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 11403번: 경로 찾기\r\n# https://www.acmicpc.net/problem/11403\r\n# 메모리/시간: 29452KB / 148ms\r\n\r\nimport sys\r\n\r\ninput = sys.stdin.readline\r\n\r\nN = int(input())\r\n\r\n_map = [list(map(int, input().split())) for _ in range(N)]\r\n\r\ndef dfs(x):\r\n    for i in range(N):\r\n        if (_map[x][i] == 1) and (visited[i] == 0):\r\n            visited[i] = 1\r\n            dfs(i)\r\n\r\nfor i in range(N):\r\n    visited = [0] * N\r\n    dfs(i)\r\n    print(*visited)\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_10818/"},"frontmatter":{"date":"July 09, 2021","title":"[백준] 10818_최소, 최대","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 10818번: 최소, 최대\r\n# https://www.acmicpc.net/problem/10818\r\n# 메모리/시간: 153628KB / 416ms\r\n\r\nimport sys\r\n\r\ninput = sys.stdin.readline\r\n\r\nN = int(input())\r\n\r\nA = list(map(int, input().split()))\r\n\r\nprint(f\"{min(A)} {max(A)}\")\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_1212/"},"frontmatter":{"date":"July 09, 2021","title":"[백준] 1212_8진수 2진수","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 1212번: 8진수 2진수\r\n# https://www.acmicpc.net/problem/1212\r\n# 메모리/시간: 31156KB / 72ms\r\n\r\nimport sys\r\n\r\ninput = sys.stdin.readline\r\n\r\nprint(bin(int(input(), 8))[2:])\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_21918/"},"frontmatter":{"date":"July 09, 2021","title":"[백준] 21918_전구","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 21918번: 전구\r\n# https://www.acmicpc.net/problem/21918\r\n# 메모리/시간: 29452KB / 672ms\r\n\r\nimport sys\r\n\r\ninput = sys.stdin.readline\r\n\r\nN, M = map(int, input().split())\r\n\r\nbulb = [-1] + list(map(int, input().split()))\r\n\r\ndef func_1(i, x):\r\n    global bulb\r\n    bulb[i] = x\r\n\r\ndef func_2(l, r):\r\n    global bulb\r\n    for i in range(l, r+1):\r\n        if bulb[i] == 1:\r\n            bulb[i] = 0\r\n        else:\r\n            bulb[i] = 1\r\n\r\ndef func_3(l, r):\r\n    global bulb\r\n    bulb[l:r+1] = [0] * (r-l+1)\r\n\r\ndef func_4(l, r):\r\n    global bulb\r\n    bulb[l:r+1] = [1] * (r-l+1)\r\n\r\ncommand = [None, func_1, func_2, func_3, func_4]\r\n\r\nfor _ in range(M):\r\n    a, b, c = map(int, input().split())\r\n    command[a](b, c)\r\n\r\nprint(*bulb[1:])\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_1373/"},"frontmatter":{"date":"July 09, 2021","title":"[백준] 1373_2진수 8진수","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 1373번: 2진수 8진수\r\n# https://www.acmicpc.net/problem/1373\r\n# 메모리/시간: 30308KB / 72ms\r\n\r\nimport sys\r\n\r\ninput = sys.stdin.readline\r\n\r\nprint(oct(int(input(), 2))[2:])\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_20053/"},"frontmatter":{"date":"July 09, 2021","title":"[백준] 20053_최소, 최대 2","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 20053번: 최소, 최대 2\r\n# https://www.acmicpc.net/problem/20053\r\n# 메모리/시간: 183516KB / 1092ms\r\n\r\nimport sys\r\n\r\ninput = sys.stdin.readline\r\n\r\nT = int(input())\r\n\r\nfor _ in range(T):\r\n    N = int(input())\r\n    A = list(map(int, input().split()))\r\n    print(f\"{min(A)} {max(A)}\")\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_5597/"},"frontmatter":{"date":"July 09, 2021","title":"[백준] 5597_과제 안 내신 분..?","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 5597번: 과제 안 내신 분..?\r\n# https://www.acmicpc.net/problem/5597\r\n# 메모리/시간: 29200KB / 68ms\r\n\r\nimport sys\r\n\r\ninput = sys.stdin.readline\r\n\r\nstudent = set(range(1, 31))\r\n\r\nfor _ in range(28):\r\n    n = int(input().rstrip())\r\n    student.remove(n)\r\n\r\nstudent = list(student)\r\n\r\nprint(f\"{min(student)}\\n{max(student)}\")\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_18352/"},"frontmatter":{"date":"July 08, 2021","title":"[백준] 18352_특정 거리의 도시 찾기","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 18352번: 특정 거리의 도시 찾기\r\n# https://www.acmicpc.net/problem/18352\r\n# 메모리/시간: 98996KB / 1636ms\r\n\r\nimport sys\r\nfrom collections import deque\r\n\r\ninput = sys.stdin.readline\r\n\r\nN, M, K, X = map(int, input().split())\r\n\r\n_graph = [[] for _ in range(N+1)]\r\n\r\nfor _ in range(M):\r\n    a, b = map(int, input().split())\r\n    _graph[a].append(b)\r\n\r\nvisited = [False] * (N+1)\r\n\r\nanswer = []\r\n\r\ndef bfs(start):\r\n    queue = deque([(start, 0)])\r\n    visited[start] = True\r\n    while queue:\r\n        for _ in range(len(queue)):\r\n            x, cnt = queue.popleft()\r\n            if cnt == K:\r\n                answer.append(x)\r\n            elif cnt < K:\r\n                for z in _graph[x]:\r\n                    if not visited[z]:\r\n                        visited[z] = True\r\n                        queue.append((z, cnt+1))\r\n\r\nbfs(X)\r\n\r\nprint(\"\\n\".join(map(str, sorted(answer)))) if len(answer) >= 1 else print(-1)\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_2753/"},"frontmatter":{"date":"July 08, 2021","title":"[백준] 2753_윤년","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 2753번: 윤년\r\n# https://www.acmicpc.net/problem/2753\r\n# 메모리/시간: 29200KB / 68ms\r\n\r\nimport sys\r\n\r\ninput = sys.stdin.readline\r\n\r\nyear = int(input())\r\n\r\nprint(1) if (year % 4 == 0) and ((year % 100 != 0) or (year % 400 == 0)) else print(0)\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_21317/"},"frontmatter":{"date":"July 07, 2021","title":"[백준] 21317_징검다리 건너기","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 21317번: 징검다리 건너기\r\n# https://www.acmicpc.net/problem/21317\r\n# 메모리/시간: 29200KB / 72ms\r\n\r\nimport sys\r\n\r\ninput = sys.stdin.readline\r\n\r\nN = int(input())\r\n\r\nenergy = [list(map(int, input().split())) for _ in range(N-1)]\r\n\r\nK = int(input())\r\n\r\ntable = [0] + [100001] * (N-1)\r\n\r\nfor i, (s, b) in enumerate(energy):\r\n    table[i+1] = min(table[i+1], table[i]+s)\r\n    if i + 2 >= N:\r\n        continue\r\n    table[i+2] = min(table[i+2], table[i]+b)\r\n\r\nanswer = table[N-1]\r\n\r\nfor j in range(N-3):\r\n    table = [0] + [100001] * (N-1)\r\n    for i, (s, b) in enumerate(energy):\r\n        table[i+1] = min(table[i+1], table[i]+s)\r\n        if i + 2 >= N:\r\n            continue\r\n        table[i+2] = min(table[i+2], table[i]+b)\r\n        if i == j:\r\n            table[i+3] = table[i] + K\r\n    answer = min(answer, table[N-1])\r\n\r\nprint(answer)\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_2294/"},"frontmatter":{"date":"July 06, 2021","title":"[백준] 2294_동전 2","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 2294번: 동전 2\r\n# https://www.acmicpc.net/problem/2294\r\n# 메모리/시간: 29452KB / 444ms\r\n\r\nimport sys\r\n\r\ninput = sys.stdin.readline\r\n\r\nn, k = map(int, input().split())\r\n\r\ncoin = [int(input()) for _ in range(n)]\r\n\r\ntable = [10001] * (k+1)\r\ntable[0] = 0\r\n\r\nfor c in coin:\r\n    for i in range(c, k+1):\r\n        table[i] = min(table[i], table[i-c]+1)\r\n\r\nprint(table[k] if table[k] != 10001 else -1)\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_11660/"},"frontmatter":{"date":"July 06, 2021","title":"[백준] 11660_구간 합 구하기 5","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 11660번: 구간 합 구하기 5\r\n# https://www.acmicpc.net/problem/11660\r\n# 메모리/시간: 103704KB / 1372ms\r\n\r\nimport sys\r\n\r\ninput = sys.stdin.readline\r\n\r\nN, M = map(int, input().split())\r\n\r\n_map = [list(map(int, input().split())) for _ in range(N)]\r\n\r\ntable = [[0] * (N+1) for _ in range(N+1)]\r\nfor i in range(1, N+1):\r\n    for j in range(1, N+1):\r\n        table[i][j] = _map[i-1][j-1] + table[i][j-1] + table[i-1][j] - table[i-1][j-1]\r\n\r\nfor _ in range(M):\r\n    x1, y1, x2, y2 = map(int, input().split())\r\n    x1, y1 = x1 - 1, y1 - 1\r\n    print(table[x2][y2] - table[x1][y2] - table[x2][y1] + table[x1][y1])\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_2293/"},"frontmatter":{"date":"July 05, 2021","title":"[백준] 2293_동전 1","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 2293번: 동전 1\r\n# https://www.acmicpc.net/problem/2293\r\n# 메모리/시간: 29452KB / 244ms\r\n\r\nimport sys\r\n\r\ninput = sys.stdin.readline\r\n\r\nn, k = map(int, input().split())\r\n\r\ncoin = [int(input()) for _ in range(n)]\r\n\r\ntable = [0] * (k+1)\r\ntable[0] = 1\r\n\r\nfor c in coin:\r\n    for i in range(c, k+1):\r\n        table[i] += table[i-c]\r\n\r\nprint(table[k])\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_10844/"},"frontmatter":{"date":"July 05, 2021","title":"[백준] 10844_쉬운 계단 수","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 10844번: 쉬운 계단 수\r\n# https://www.acmicpc.net/problem/10844\r\n# 메모리/시간: 29200KB / 68ms\r\n\r\nimport sys\r\n\r\ninput = sys.stdin.readline\r\n\r\nN = int(input())\r\n\r\ntable = [[1] * 10] + [[0] * 10 for _ in range(N-1)]\r\n\r\nfor i in range(N-1):\r\n    for j in range(10):\r\n        if j >= 1:\r\n            table[i+1][j-1] += table[i][j]\r\n        if j <= 8:\r\n            table[i+1][j+1] += table[i][j]\r\n\r\nprint(sum(table[N-1][1:])%1000000000)\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_15486/"},"frontmatter":{"date":"July 02, 2021","title":"[백준] 15486_퇴사 2","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 15486번: 퇴사 2\r\n# https://www.acmicpc.net/problem/15486\r\n# 메모리/시간: 344988KB / 4384ms\r\n\r\nimport sys\r\n\r\ninput = sys.stdin.readline\r\n\r\nN = int(input())\r\n\r\ninfo = [[0, 0]] + [list(map(int, input().split())) for _ in range(N)]\r\ntable = [0] * (N+2)\r\n\r\nfor i in range(1, N+1):\r\n    if i + info[i][0] <= N + 1:\r\n        table[i+info[i][0]] = max(table[i+info[i][0]], table[i]+info[i][1])\r\n    table[i+1] = max(table[i+1], table[i])\r\n\r\nprint(table[N+1])\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_2156/"},"frontmatter":{"date":"July 02, 2021","title":"[백준] 2156_포도주 시식","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 2156번: 포도주 시식\r\n# https://www.acmicpc.net/problem/2156\r\n# 메모리/시간: 32568KB / 96ms\r\n\r\nimport sys\r\nfrom collections import defaultdict\r\n\r\ninput = sys.stdin.readline\r\n\r\nn = int(input())\r\n\r\nwine = [0] + [int(input()) for _ in range(n)]\r\ntable = defaultdict(int)\r\n\r\nfor i in range(1, n+1):\r\n    table[i] = max(table[i-1], wine[i]+table[i-2], wine[i]+wine[i-1]+table[i-3])\r\n\r\nprint(table[n])\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_1106/"},"frontmatter":{"date":"July 01, 2021","title":"[백준] 1106_호텔","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 1106번: 호텔\r\n# https://www.acmicpc.net/problem/1106\r\n# 메모리/시간: 29200KB / 72ms\r\n\r\nimport sys\r\n\r\ninput = sys.stdin.readline\r\n\r\nC, N = map(int, input().split())\r\n\r\ninfo = dict()\r\n\r\nfor _ in range(N):\r\n    cost, customer = map(int, input().split())\r\n    if customer in info.keys():\r\n        info[customer] = min(info[customer], cost)\r\n    else:\r\n        info[customer] = cost\r\n\r\ntable = [0] + [999999] * (C+max(info.keys()))\r\n\r\nfor customer, cost in info.items():\r\n    for i in range(customer, len(table)):\r\n        table[i] = min(table[i], table[i-customer]+cost)\r\n\r\nprint(min(table[C:]))\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_2407/"},"frontmatter":{"date":"July 01, 2021","title":"[백준] 2407_조합","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n\r\n###### 2407번: 조합\r\n# https://www.acmicpc.net/problem/2407\r\n# 메모리/시간: 29200KB / 64ms\r\n\r\nimport sys\r\n\r\ninput = sys.stdin.readline\r\n\r\nn, m = map(int, input().split())\r\ntable = [1] * (n+1)\r\n\r\nnum = 1\r\nfor i in range(1, n+1):\r\n    num *= i\r\n    table[i] = num\r\n\r\nprint(table[n] // (table[m] * table[n-m]))\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_11055/"},"frontmatter":{"date":"June 30, 2021","title":"[백준] 11055_가장 큰 증가 부분 수열","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 11055번: 가장 큰 증가 부분 수열\r\n# https://www.acmicpc.net/problem/11055\r\n# 메모리/시간: 29200KB / 196ms\r\n\r\nimport sys\r\n\r\ninput = sys.stdin.readline\r\n\r\nN = int(input())\r\n\r\nA = list(map(int, input().split()))\r\n\r\ntable = [x for x in A]\r\n\r\nfor i in range(N):\r\n    for j in range(i):\r\n        if (A[i] > A[j]) and (table[i] < table[j] + A[i]):\r\n            table[i] = table[j] + A[i]\r\n\r\nprint(max(table))\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_1890/"},"frontmatter":{"date":"June 30, 2021","title":"[백준] 1890_점프","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 1890번: 점프\r\n# https://www.acmicpc.net/problem/1890\r\n# 메모리/시간: 29200KB / 68ms\r\n\r\nimport sys\r\n\r\ninput = sys.stdin.readline\r\n\r\nN = int(input())\r\n\r\n_map = tuple(tuple(map(int, input().split())) for _ in range(N))\r\ntable = [[-1] * N for _ in range(N)]\r\n\r\ndef dfs(x, y):\r\n    if (x, y) == (N-1, N-1):\r\n        return 1\r\n    if table[x][y] == -1:\r\n        table[x][y] = 0\r\n        x1, y1 = x + _map[x][y], y\r\n        x2, y2 = x, y + _map[x][y]\r\n        if (x1 >= 0) and (x1 < N) and (y1 >= 0) and (y1 < N):\r\n            table[x][y] += dfs(x1, y1)\r\n        if (x2 >= 0) and (x2 < N) and (y2 >= 0) and (y2 < N):\r\n            table[x][y] += dfs(x2, y2)\r\n    return table[x][y]\r\n\r\nprint(dfs(0, 0))\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_1912/"},"frontmatter":{"date":"June 29, 2021","title":"[백준] 1912_연속합","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 1912번: 연속합\r\n# https://www.acmicpc.net/problem/1912\r\n# 메모리/시간: 37288KB / 112ms\r\n\r\nimport sys\r\n\r\ninput = sys.stdin.readline\r\n\r\nn = int(input())\r\n\r\nA = tuple(map(int, input().split()))\r\n\r\ntable = [x for x in A]\r\n\r\nfor i in range(1, n):\r\n    if table[i] < table[i-1] + A[i]:\r\n        table[i] = table[i-1] + A[i]\r\n\r\nprint(max(table))\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_9465/"},"frontmatter":{"date":"June 29, 2021","title":"[백준] 9465_스티커","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 9465번: 스티커\r\n# https://www.acmicpc.net/problem/9465\r\n# 메모리/시간: 47576KB / 1532ms\r\n\r\nimport sys\r\n\r\ninput = sys.stdin.readline\r\n\r\nT = int(input())\r\n\r\nfor _ in range(T):\r\n    n = int(input())\r\n    _map = tuple(tuple(map(int, input().split())) for _ in range(2))\r\n    table = [[0 for _ in range(n)] for _ in range(2)]\r\n    \r\n    table[0][0] = _map[0][0]\r\n    table[1][0] = _map[1][0]\r\n    table[0][1] = table[1][0] + _map[0][1]\r\n    table[1][1] = table[0][0] + _map[1][1]\r\n\r\n    for i in range(2, n):\r\n        table[0][i] = max(table[1][i-1]+_map[0][i], max(table[0][i-2], table[1][i-2])+_map[0][i])\r\n        table[1][i] = max(table[0][i-1]+_map[1][i], max(table[0][i-2], table[1][i-2])+_map[1][i])\r\n\r\n    print(max(max(table[0]), max(table[1])))\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_11053/"},"frontmatter":{"date":"June 28, 2021","title":"[백준] 11053_가장 긴 증가하는 부분 수열","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 11053번: 가장 긴 증가하는 부분 수열\r\n# https://www.acmicpc.net/problem/11053\r\n# 메모리/시간: 29200KB / 152ms\r\n\r\nimport sys\r\n\r\ninput = sys.stdin.readline\r\n\r\nN = int(input())\r\n\r\nA = list(map(int, input().split()))\r\n\r\ntable = [0 for _ in range(N)]\r\n\r\nfor i in range(N):\r\n    for j in range(i):\r\n        if (A[i] > A[j]) and (table[i] < table[j]):\r\n            table[i] = table[j]\r\n    table[i] += 1\r\n\r\nprint(max(table))\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_11727/"},"frontmatter":{"date":"June 28, 2021","title":"[백준] 11727_2×n 타일링 2","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 11727번: 2×n 타일링 2\r\n# https://www.acmicpc.net/problem/11727\r\n# 메모리/시간: 32040KB / 88ms\r\n\r\nimport sys\r\nfrom collections import defaultdict\r\n\r\ninput = sys.stdin.readline\r\n\r\nn = int(input())\r\n\r\ndef tiling(n):\r\n    table = defaultdict(int)\r\n    table[0] = 1\r\n    for i in range(1, n+1):\r\n        table[i] = table[i-1] + table[i-2]*2\r\n    return table[n]\r\n\r\nprint(tiling(n) % 10007)\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_11726/"},"frontmatter":{"date":"June 25, 2021","title":"[백준] 11726_2×n 타일링","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 11726번: 2xn 타일링\r\n# https://www.acmicpc.net/problem/11726\r\n# 메모리/시간: 32040KB / 100ms\r\n\r\nimport sys\r\nfrom collections import defaultdict\r\n\r\ninput = sys.stdin.readline\r\n\r\nn = int(input())\r\n\r\ndef tiling(n):\r\n    table = defaultdict(int)\r\n    table[1], table[2] = 1, 2\r\n    for i in range(3, n+1):\r\n        table[i] = table[i-1] + table[i-2]\r\n    return table[n]\r\n\r\nprint(tiling(n) % 10007)\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_2579/"},"frontmatter":{"date":"June 25, 2021","title":"[백준] 2579_계단 오르기","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 2579번: 계단 오르기\r\n# https://www.acmicpc.net/problem/2579\r\n# 메모리/시간: 31856KB / 88ms\r\n\r\nimport sys\r\nfrom collections import defaultdict\r\n\r\ninput = sys.stdin.readline\r\n\r\nN = int(input())\r\n\r\ntable = defaultdict(int)\r\ndp = defaultdict(int)\r\n\r\nfor i in range(1, N+1):\r\n    table[i] = int(input().rstrip())\r\n\r\nfor i in range(1, N+1):\r\n    dp[i] = max(dp[i-2]+table[i], dp[i-3]+table[i]+table[i-1])\r\n\r\nprint(dp[N])\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_1463/"},"frontmatter":{"date":"June 24, 2021","title":"[백준] 1463_1로 만들기","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n\r\n###### 1463번: 1로 만들기\r\n# https://www.acmicpc.net/problem/1463\r\n# 메모리/시간: 37012KB / 636ms\r\n\r\nimport sys\r\n\r\ninput = sys.stdin.readline\r\n\r\nN = int(input())\r\n\r\ntable = [0] * (N+1)\r\n\r\nfor i in range(2, N+1):\r\n    table[i] = table[i-1] + 1\r\n    if i % 2 == 0:\r\n        table[i] = min(table[i], table[i//2]+1)\r\n    if i % 3 == 0:\r\n        table[i] = min(table[i], table[i//3]+1)\r\n\r\nprint(table[N])\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_9095/"},"frontmatter":{"date":"June 24, 2021","title":"[백준] 9095_1, 2, 3 더하기","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 9095번: 1, 2, 3 더하기\r\n# https://www.acmicpc.net/problem/9095\r\n# 메모리/시간: 31824KB / 96ms\r\n\r\nimport sys\r\nfrom collections import defaultdict\r\n\r\ninput = sys.stdin.readline\r\n\r\nT = int(input())\r\n\r\ndef one_two_three(n):\r\n    table = defaultdict(int)\r\n    table[0] = 1\r\n    \r\n    for i in range(1, n+1):\r\n        table[i] = table[i-1] + table[i-2] + table[i-3]\r\n    \r\n    return table[n]\r\n\r\nfor _ in range(T):\r\n    n = int(input())\r\n    print(one_two_three(n))\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_17626/"},"frontmatter":{"date":"June 23, 2021","title":"[백준] 17626_Four Squares","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 17626번: Four Squares\r\n# https://www.acmicpc.net/problem/17626\r\n# 메모리/시간: 31900KB / 356ms\r\n\r\nimport sys\r\nfrom collections import defaultdict\r\n\r\ninput = sys.stdin.readline\r\n\r\nn = int(input())\r\n\r\ntable = defaultdict(int)\r\n\r\nfor i in range(int(n**0.5)+1):\r\n    table[i] = i * i\r\n\r\ndef four_squares(n):\r\n    for i in range(len(table)-1, 0, -1):\r\n        if table[i] == n:\r\n            return 1\r\n    for i in range(len(table)-1, 0, -1):\r\n        for j in range(i, 0, -1):\r\n            _sum = table[i] + table[j]\r\n            if _sum == n:\r\n                return 2\r\n    for i in range(len(table)-1, 0, -1):\r\n        for j in range(i, 0, -1):\r\n            for k in range(j, 0, -1):\r\n                _sum = table[i] + table[j] + table[k]\r\n                if _sum == n:\r\n                    return 3\r\n    return 4\r\n\r\ncnt = four_squares(n)\r\n\r\nprint(cnt)\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_9655/"},"frontmatter":{"date":"June 23, 2021","title":"[백준] 9655_돌 게임","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 9655번: 돌 게임\r\n# https://www.acmicpc.net/problem/9655\r\n# 메모리/시간: 29200KB / 72ms\r\n\r\nimport sys\r\n\r\ninput = sys.stdin.readline\r\n\r\nN = int(input())\r\n\r\ncnt = 0\r\n\r\nwhile N > 0:\r\n    if N % 3 == 0:\r\n        cnt += N // 3\r\n        break\r\n    N -= 1\r\n    cnt += 1\r\n\r\nprint(\"SK\") if cnt % 2 == 1 else print(\"CY\")\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_1010/"},"frontmatter":{"date":"June 22, 2021","title":"[백준] 1010_다리 놓기","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 1010번: 다리 놓기\r\n# https://www.acmicpc.net/problem/1010\r\n# 메모리/시간: 29200KB / 72ms\r\n\r\nimport sys\r\n\r\ninput = sys.stdin.readline\r\n\r\ndef factorial(n):\r\n    num = 1\r\n    for i in range(1, n+1):\r\n        num *= i\r\n    return num\r\n\r\nT = int(input())\r\n\r\nfor _ in range(T):\r\n    N, M = map(int, input().split())\r\n    print(int(factorial(M) / (factorial(N) * factorial(M-N))))\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_2748/"},"frontmatter":{"date":"June 22, 2021","title":"[백준] 2748_피보나치 수 2","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 2748번: 피보나치 수 2\r\n# https://www.acmicpc.net/problem/2748\r\n# 메모리/시간: 29200KB / 68ms\r\n\r\nimport sys\r\n\r\ninput = sys.stdin.readline\r\n\r\nn = int(input())\r\n\r\ndef fibonacci(n):\r\n    a, b = 0, 1\r\n    for i in range(n):\r\n        a, b = b, a + b\r\n    return a\r\n\r\nprint(fibonacci(n))\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_10870/"},"frontmatter":{"date":"June 21, 2021","title":"[백준] 10870_피보나치 수 5","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 10870번: 피보나치 수 5\r\n# https://www.acmicpc.net/problem/10870\r\n# 메모리/시간: 29200KB / 68ms\r\n\r\nimport sys\r\n\r\ninput = sys.stdin.readline\r\n\r\nn = int(input())\r\n\r\ndef fibonacci(n):\r\n    if n <= 1:\r\n        return n\r\n    return fibonacci(n-1) + fibonacci(n-2)\r\n\r\nprint(fibonacci(n))\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_2839/"},"frontmatter":{"date":"June 21, 2021","title":"[백준] 2839_설탕 배달","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 2839번: 설탕 배달\r\n# https://www.acmicpc.net/problem/2839\r\n# 메모리/시간: 29200KB / 72ms\r\n\r\nimport sys\r\n\r\ninput = sys.stdin.readline\r\n\r\nN = int(input())\r\n\r\ncnt = 0\r\n\r\nwhile N >= 0:\r\n    if N % 5 == 0:\r\n        cnt += N // 5\r\n        print(cnt)\r\n        break\r\n    N -= 3\r\n    cnt += 1\r\nelse:\r\n    print(-1)\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_17073/"},"frontmatter":{"date":"June 18, 2021","title":"[백준] 17073_나무 위의 빗물","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 17073번: 나무 위의 빗물\r\n# https://www.acmicpc.net/problem/17073\r\n# 메모리/시간: 73304KB / 916ms\r\n\r\nimport sys\r\nfrom collections import defaultdict\r\n\r\ninput = sys.stdin.readline\r\n\r\nN, W = map(int, input().split())\r\n\r\ntree = defaultdict(int)\r\n\r\nfor _ in range(N-1):\r\n    U, V = map(int, input().split())\r\n    tree[U] += 1\r\n    tree[V] += 1\r\n\r\nleaf_node = 0\r\n\r\nfor u, v in tree.items():\r\n    if (u != 1) and (v == 1):\r\n        leaf_node += 1\r\n\r\nprint(W / leaf_node)\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_14675/"},"frontmatter":{"date":"June 17, 2021","title":"[백준] 14675_단절점과 단절선","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 14675번: 단절점과 단절선\r\n# https://www.acmicpc.net/problem/14675\r\n# 메모리/시간: 44316KB / 320ms\r\n\r\nimport sys\r\n\r\ninput = sys.stdin.readline\r\n\r\nN = int(input())\r\ntree = [[] for _ in range(N+1)]\r\n\r\nfor _ in range(N-1):\r\n    a, b = map(int, input().split())\r\n    tree[a].append(b)\r\n    tree[b].append(a)\r\n\r\nq = int(input())\r\nfor _ in range(q):\r\n    t, k = map(int, input().split())\r\n    cond = False\r\n    \r\n    if t == 1:\r\n        if len(tree[k]) > 1:\r\n            cond = True\r\n    else:\r\n        cond = True\r\n\r\n    if cond:\r\n        print(\"yes\")\r\n    else:\r\n        print(\"no\")\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_1068/"},"frontmatter":{"date":"June 15, 2021","title":"[백준] 1068_트리","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 1068번: 트리\r\n# https://www.acmicpc.net/problem/1068\r\n# 메모리/시간: 31780KB / 92ms\r\n\r\nimport sys\r\nfrom collections import deque\r\n\r\ninput = sys.stdin.readline\r\n\r\nN = int(input())\r\nparents = list(map(int, input().split()))\r\ndel_node = int(input())\r\n\r\ntree = [[] for _ in range(N)]\r\n\r\nfor i, par in enumerate(parents):\r\n    if par != -1:\r\n        tree[par].append(i)\r\n\r\nfor i, x in enumerate(tree):\r\n    tree[i] = set(x)\r\n\r\ndef bfs(start, visited):\r\n    queue = deque([start])\r\n    visited[start] = True\r\n    while queue:\r\n        v = queue.popleft()\r\n        for i in tree[v]:\r\n            if (not visited[i]):\r\n                queue.append(i)\r\n                visited[i] = True\r\n\r\nvisited = [False for _ in range(N)]\r\n\r\nbfs(del_node, visited)\r\n\r\ncnt = 0\r\n\r\nfor x, b in zip(tree, visited):\r\n    if len(x) == 0 and not b:\r\n        cnt += 1\r\n    if x == {del_node}:\r\n        cnt += 1\r\n\r\nprint(cnt)\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_1991/"},"frontmatter":{"date":"June 14, 2021","title":"[백준] 1991_트리 순회","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 1991번: 트리 순회\r\n# https://www.acmicpc.net/problem/1991\r\n# 메모리/시간: 29200KB / 64ms\r\n\r\nimport sys\r\n\r\ninput = sys.stdin.readline\r\n\r\nN = int(input())\r\n\r\ntree = dict()\r\n\r\nfor _ in range(N):\r\n    node, left, right = input().split()\r\n    tree[node] = [left, right]\r\n\r\ndef preorder_traversal(node):\r\n    global preorder\r\n    left, right = tree[node]\r\n    preorder.append(node)\r\n    if left != \".\":\r\n        preorder_traversal(left)\r\n    if right != \".\":\r\n        preorder_traversal(right)\r\n\r\ndef inorder_traversal(node):\r\n    global inorder\r\n    left, right = tree[node]\r\n    if left != \".\":\r\n        inorder_traversal(left)\r\n    inorder.append(node)\r\n    if right != \".\":\r\n        inorder_traversal(right)\r\n\r\ndef postorder_traversal(node):\r\n    global postorder\r\n    left, right = tree[node]\r\n    if left != \".\":\r\n        postorder_traversal(left)\r\n    if right != \".\":\r\n        postorder_traversal(right)\r\n    postorder.append(node)\r\n\r\npreorder = []\r\ninorder = []\r\npostorder = []\r\n\r\npreorder_traversal(\"A\")\r\ninorder_traversal(\"A\")\r\npostorder_traversal(\"A\")\r\n\r\nprint(\"\".join(map(str, preorder)))\r\nprint(\"\".join(map(str, inorder)))\r\nprint(\"\".join(map(str, postorder)))\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_5639/"},"frontmatter":{"date":"June 14, 2021","title":"[백준] 5639_이진 검색 트리","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 5639번: 이진 검색 트리\r\n# https://www.acmicpc.net/problem/5639\r\n# 메모리/시간: 38456KB / 4508ms\r\n\r\nimport sys\r\n\r\nsys.setrecursionlimit(10**6)\r\ninput = sys.stdin.readline\r\n\r\npreorder = []\r\n\r\nwhile True:\r\n    _input = input()\r\n    if _input == \"\":\r\n        break\r\n    preorder.append(int(_input))\r\n\r\ndef postorder(start, end):\r\n    if start > end:\r\n        return None\r\n    \r\n    root = preorder[start]\r\n    idx = start + 1\r\n    \r\n    while idx <= end:\r\n        if preorder[idx] > root:\r\n            break\r\n        idx += 1\r\n    \r\n    postorder(start+1, idx-1)\r\n    postorder(idx, end)\r\n    print(root)\r\n\r\npostorder(0, len(preorder)-1)\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_9934/"},"frontmatter":{"date":"June 11, 2021","title":"[백준] 9934_완전 이진 트리","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 9934번: 완전 이진 트리\r\n# https://www.acmicpc.net/problem/9934\r\n# 메모리/시간: 29200KB / 68ms\r\n\r\nimport sys\r\n\r\ninput = sys.stdin.readline\r\n\r\nK = int(input())\r\n\r\nnode = list(map(int, input().split()))\r\nnode.insert(0, 0)\r\ntree = [[] for _ in range(K)]\r\n\r\nfor i in range(K-1, -1, -1):\r\n    j = 2**i\r\n    tmp = []\r\n    while j < len(node):\r\n        if node[j] != 0:\r\n            tree[i].append(node[j])\r\n            node[j] = 0\r\n        j += 2**i\r\n\r\nfor i in range(K-1, -1, -1):\r\n    print(\" \".join(map(str, tree[i])))\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_20437/"},"frontmatter":{"date":"June 10, 2021","title":"[백준] 20437_문자열 게임 2","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 20437번: 문자열 게임 2\r\n# https://www.acmicpc.net/problem/20437\r\n# 메모리/시간: 32156KB / 276ms\r\n\r\nimport sys\r\nfrom collections import deque, Counter, defaultdict\r\n\r\ninput = sys.stdin.readline\r\n\r\nT = int(input())\r\n\r\ndef str_game(dict):\r\n    global K\r\n    length = deque([-1])\r\n    for k, v in dict.items():\r\n        if len(v) >= K:\r\n            for i in range(len(v)-K+1):\r\n                length.append(v[i+K-1] - v[i] + 1)\r\n    return length\r\n\r\nfor i in range(T):\r\n    W = input().rstrip()\r\n    K = int(input().rstrip())\r\n    c = Counter(W)\r\n    if max(c.values()) < K:\r\n        print(-1)\r\n        continue\r\n    d = defaultdict(list)\r\n    for i, x in enumerate(W):\r\n        d[x].append(i)\r\n    game = str_game(d)\r\n    if len(game) == 1:\r\n        print(-1)\r\n    else:\r\n        game.popleft()\r\n        print(f\"{min(game)} {max(game)}\")\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_17413/"},"frontmatter":{"date":"June 09, 2021","title":"[백준] 17413_단어 뒤집기 2","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 17413번: 단어 뒤집기 2\r\n# https://www.acmicpc.net/problem/17413\r\n# 메모리/시간: 42932KB / 188ms\r\n\r\nimport sys\r\nfrom collections import deque\r\n\r\ninput = sys.stdin.readline\r\n\r\n_input = input().rstrip()\r\nanswer = [\"\"] * len(_input)\r\nd = dict()\r\ncond = False\r\n\r\nfor i, x in enumerate(_input):\r\n    if (x == \"<\") and not cond:\r\n        answer[i] = x\r\n        cond = True\r\n    elif x == \">\":\r\n        answer[i] = x\r\n        cond = False\r\n    elif cond or x == \" \":\r\n        answer[i] = x\r\n    else:\r\n        d[i] = x\r\n\r\ntmp = \"\"\r\nword = []\r\ns_idx = []\r\n\r\nfor i, x in d.items():\r\n    if i+1 in d.keys():\r\n        tmp += x\r\n    else:\r\n        tmp += x\r\n        word.append(tmp[::-1])\r\n        tmp = \"\"\r\n        s_idx.append(i)\r\n\r\nz = 0\r\nfor i in s_idx:\r\n    answer[i] = word[z]\r\n    z += 1\r\nprint(\"\".join(map(str, answer)))\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_17609/"},"frontmatter":{"date":"June 09, 2021","title":"[백준] 17609_회문","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 17609번: 회문\r\n# https://www.acmicpc.net/problem/17609\r\n# 메모리/시간: 29200KB / 260ms\r\n\r\nimport sys\r\n\r\ninput = sys.stdin.readline\r\n\r\nT = int(input())\r\n\r\ndef check_2(string, left, right):\r\n    while (left < right):\r\n        if string[left] == string[right]:\r\n            left += 1\r\n            right -= 1\r\n        else:\r\n            return False\r\n    return True\r\n\r\ndef check(string, left, right):\r\n    while (left < right):\r\n        if string[left] == string[right]:\r\n            left += 1\r\n            right -= 1\r\n        else:\r\n            cond1 = check_2(string, left+1, right)\r\n            cond2 = check_2(string, left, right-1)\r\n            if any([cond1, cond2]):\r\n                return 1\r\n            else:\r\n                return 2\r\n    return 0\r\n\r\nfor _ in range(T):\r\n    _input = input().rstrip()\r\n    left = 0\r\n    right = len(_input) - 1\r\n    print(check(_input, left, right))\r\n```"},{"excerpt":"TabNet 1. Abstract Sequential attention을 사용해서 각각의 decision step마다 여러 feature들 중에 중요한 feature들만 고름 tabular data의 self-supervised learning…","fields":{"slug":"/TabNet/"},"frontmatter":{"date":"June 08, 2021","title":"TabNet: Attentive Interpretable Tabular Learning","tags":["Paper Review","Tabular Data","TabNet"]},"rawMarkdownBody":"\r\n## TabNet\r\n\r\n<img src=\"tabnet.PNG\">\r\n\r\n## 1. Abstract\r\n\r\n- Sequential attention을 사용해서 각각의 decision step마다 여러 feature들 중에 중요한 feature들만 고름\r\n- tabular data의 self-supervised learning도 가능함 (label이 안되어있는..)\r\n\r\n## 2. Related work\r\n\r\n### 1. Feature selection\r\n\r\n- global methods: feature importance를 기반으로 하여 feature selection\r\n- Instance-wise feature selection: response variable과 선택된 feature들간의 공통 정보를 최대화 하기 위해 explainer model을 사용해서 feature를 individually하게 뽑음\r\n- TabNet: soft feature selection with controllable sparsity in end-to-end learning  \r\n  → 단일 모델이 feature selection을 하고 output mapping까지 하는 구조\r\n\r\n### 2. Tree-based learning\r\n\r\n- tabular data를 위해 많이 사용\r\n- variance를 줄이기 위해 앙상블 기법을 사용  \r\n  → random forests, XGBoost, LightGBM 등이 있음\r\n- 딥러닝이 feature selecting property를 retrainig 시키면 성능이 더 오를 수 있다고 주장\r\n\r\n### 3. Integration of DNNs into DTs\r\n\r\n### 4. Self-supervised learning\r\n\r\n<img src=\"self-supervised learning.png\">\r\n\r\n- small data에서 unsupervised representation learning이 성능을 향상시킴을 보임\r\n- 최근 연구에서는 text와 image에서 큰 성능 향상의 폭을 보임\r\n  - unsupervised learning과 딥러닝에서 현명한 masking을 통해서 학습을 시키면 좀 더 오름\r\n\r\n## 3. Unsupervised pre-training vs Supervised fine-tuning\r\n\r\n<img src=\"self-supervised learning.png\">\r\n\r\n- Unsupervised Pre-training은 Mask를 씌우고 Mask를 씌운 부분을 맞추는 방법\r\n    - Label이 따로 필요 없음\r\n    - 엄청난 loss...\r\n- Supervised fine-tuning은 다 채워진 tabular data를 가지고 Decision making을 하는 방법\r\n\r\n## 4. Tabnet 특징\r\n\r\n1. Data에서 Sparse instance-wise feature selection을 사용\r\n  - salient features(두드러진 feature)들을 선택(selection)하는 것은 높은 성능을 내는데 중요한 요소(특히 dataset이 작을 때)\r\n  - 따라서 dataset에서 subset을 만들어 determine(결정)하도록 재구성함\r\n\r\n  <img src=\"feature_subset.PNG\">\r\n\r\n  - 위의 표와 같이 feature에 따른 subset을 만든 것이 Syn1 ~ Syn6 까지임\r\n  - 여기서 Syn1 ~ Syn3까지의 값은 feature들끼리 독립적인 feature들을 사용\r\n    - 이렇게 사용하면 global feature (성능이 가장 잘 나오는 이상적인 feature)에 가까워짐\r\n  - 하지만 Syn4 ~ Syn6까지는 feature들끼리의 종속성이 존재함\r\n    - instance끼리의 wise한 feature들\r\n    - 이렇게 사용하면 global selection이 suboptimal로 선택되면서 성능이 낮아질 수 있음\r\n  - 하지만 Tabnet은 instance-wise feature들을 sparse하게 사용하면서 global feature에 가까워지게 만들어줌\r\n\r\n2. Sequential한 multi-step architecture을 가지고 있음\r\n\r\n- 각 step들은 선택된 feature들을 가지고 decision을 내리는데 도움을 줌\r\n\r\n3. feature 선택에 있어 non-linear한 processing을 사용하면서 learning capacity를 향상시킴\r\n\r\n## 5. Tabnet 전체 Architecture\r\n\r\n<img src=\"tabnet_encoder.PNG\">\r\n\r\n<img src=\"tabnet_decoder.PNG\">\r\n\r\n- 전체적으로는 Tabnet의 Encoder 부분과 Decoder 부분으로 구성됨\r\n- Encoder 부분은 Sequential한 multi-setp processing ($$N_{steps}$$ decision steps로 구성됨)\r\n- Decoder는 self-supervised learning을 할 때만 사용함\r\n\r\n## 6. Feature selection\r\n\r\n<img src=\"learnable_mask.png\">\r\n\r\n- Learnable Mask $$M[i] \\in R^{B \\times D}$$를 사용\r\n    - salient feature들을 selection 하기 위해 사용함\r\n\r\n- **Attentive transformer 사용**\r\n\r\n  <img src=\"attentive_transformer.PNG\">\r\n\r\n  - 이전 단계에서 처리된 features들을 사용하여 mask를 얻는 방법\r\n  - $$M[i] = sparsemax(P[i-1] \\cdot h_{i}(a[i-1]))$$\r\n    - $$a[i-1]$$: 이전 단계에서 처리된 feature\r\n    - $$h_{i}$$: trainable function\r\n      - FC layer와 BN을 의미함\r\n    - $$P[i]$$: prior scale term\r\n      - 특정한 feature가 이전에 얼마나 사용되었는지를 나타냄\r\n      - $$P[i] = \\prod^{i}_{j=1} ( \\gamma - M[j] )$$\r\n        - $$\\gamma$$는 relaxation parameter\r\n          - $$\\gamma = 1$$일 때, feature가 한 decision step에서 한개만 사용하도록 함\r\n          - $$\\gamma$$가 증가하면 여러 decision step에서 feature들을 사용할 수 있음\r\n        - $$P[0]$$이면 $$1^{B \\times D}$$로 초기화 (모두 $$1$$로 초기화)\r\n          - 1이면 feature를 사용한다는 의미이므로, feature를 사용하지 않을 때 $$P[0]$$을 $$0$$으로 만들어줌\r\n\r\n## 7. Feature processing\r\n\r\n<img src=\"feature_processing.PNG\">\r\n\r\n- **Feature transformer 사용**\r\n\r\n  <img src=\"feature_transformer.PNG\">\r\n\r\n  - 대용량을 처리할 때도 robust한 learning을 만들기 위해서는, feature transformer는 `모든 decision step에서 공유되는 layer`와 `decision step-dependents layer`로 구성\r\n    - `모든 decision step에서 공유되는 layer`를 쓰는 이유는 같은 feature들 모두 다른 decision step의 input으로 들어가기 때문\r\n    - `decision-step-dependents layer`는 해당 decision일 때만 사용하는 feature들을 processing하는 부분\r\n  - 위 사진에서는 다음과 같이 구성됨\r\n    - 두 개의 shared layer\r\n    - 두 개의 decision step-dependent layers\r\n  - FC → BN → GLU로 연결\r\n    - 밑에 있는 화살표는 normalized residual connection\r\n    - Residual connection을 $$\\sqrt{0.5}$$로 정규화하는 이유는 network 전체의 분산이 크게 변화지 않게 함으로써 학습 안정화에 도움이 됨 (Gehring et al. 2017)\r\n  - 빠른 training을 위해 BN과 함께 large batch size를 사용해도 됨\r\n    - ghost BN..?\r\n  - Aggregation\r\n    - 모든 decision을 embedding $$d[i]$$\r\n    - $$d_{out} = \\sum^{N_{steps}}_{i=1} RELU(d[i])$$\r\n    - 이후, 마지막 linear를 태움: $$W_{final} d_{out}$$\r\n\r\n- decision step의 output을 split함\r\n\r\n## 8. Interpretability (해석 가능성)\r\n\r\n- tabnet의 feature selection mask는 선택된 feature에서 강조표시를 할 수 있음\r\n  - 일단, $$M_{b,j}[i] = 0$$이면, decision에 참여할 권한 없음\r\n  - $$M_{b,j}[i]$$ 계수는 feature importance를 나타내는 $$f_{b,j}$$라고 볼 수 있음.\r\n    ($$f_{i}$$가 linear function일 때)\r\n    - 그렇지만 각각의 decision step이 non-linear하다고 하더라도, output을 linear하게 합치면 되기 때문에 상관없음\r\n  - 서로 다른 단계에 있는 mask를 합치려면, decision의 각 단계에서 상대적 중요도를 평가할 수 있는 계수가 필요\r\n    - 논문에서는 $$\\eta b[i] = \\sum^{N_{d}}_{c=1} RELU(d_{b,c}[i])$$\r\n      - 즉, $$i^{th}$$번째 decision과 $$b^{th}$$의 sample들을 aggregate한 decision\r\n    - 위 식을 사용해서 aggregate feature importance mask를 찾는 방법은 다음과 같음\r\n      - $$M_{agg-b,j} = \\frac {\\sum^{N_{steps}}_{i=1} \\eta b[i]M_{b,j}[i]} {\\sum^{D}_{j=1} \\sum^{N_{steps}}_{i=1} \\eta b[i] M_{b,j}[i]}$$\r\n\r\n## 9. self-supervised learning\r\n\r\n<img src=\"tabnet_decoder.PNG\">\r\n\r\n- Self-supervised learning을 하기 위해 Decoder를 사용\r\n- Decoder는 feature transformers, FC를 사용함\r\n- mask를 씌운 부분을 맞추는 것이기 때문에 binary mask인 $$S \\in \\{0,1\\}^{B \\times D}$$를 사용\r\n- Tabnet encoder에는 $$(1 - S) \\cdot \\hat{f}$$를 input으로 넣음  \r\n  Tabnet decoder는 reconstructed featres인 $$S \\cdot \\hat{f}$$를 출력함  \r\n- Reconstruction loss는 다음과 같이 계산됨\r\n\r\n<img src=\"reconstruction_loss.png\">\r\n\r\n- We sample $$S_{b,j}$$ independently from a **Bernoulli distribution** with parameter $$p_{s}$$, at each iteration.\r\n\r\n---\r\n\r\n## 결과\r\n\r\n- Regression과 Classification task를 수행할 수 있음\r\n- Forest Cover Type Dataset에서 높은 accuracy를 보여줌\r\n\r\n<img src=\"result.png\">\r\n\r\n<img src=\"result2.png\">\r\n\r\n- Pocker Hand dataset에서도 좋은 성능을 보여줌\r\n\r\n<img src=\"result3.png\">\r\n\r\n<img src=\"result4.png\">\r\n\r\n- Self-supervised learning에서 Dataset size가 크고, pre-training을 함께 진행했을 때 좋은 성능이 나오게됨\r\n\r\n<img src=\"result5.png\">\r\n\r\n## Hyperparameter 설정 방법\r\n\r\n$$N_d, N_a = \\{8, 16, 24, 32, 64, 128\\}$$  \r\n$$N_{steps} = \\{3, 4, 5, 6, 7, 8, 9, 10\\}$$  \r\n$$\\gamma = \\{1.0, .12, 1.5, 2.0\\}$$  \r\n$$\\lambda_{sparse} = \\{0, 0.000001, 0.0001, 0.001, 0.01, 0.1\\}$$  \r\n$$B = \\{256, 512, 1024, 2048, 4096, 8192, 16384, 32768\\}$$  \r\n$$B_V = \\{256, 512, 1024, 2048, 4096\\}$$  \r\n$$lr = \\{0.005, 0.01, 0:02, 0.025\\}$$  \r\n$$decay \\ rate = \\{0.4, 0.8, 0.9, 0.95\\}$$  \r\n\r\n- **Guidelines for hyperparameters**\r\n  - $$N_{steps}$$는 [3, 10] 사이가 optimal하다.\r\n    - 너무 높은 $$N_{steps}$$를 사용하면 overfitting의 문제가 생길 수 있다\r\n  - $$N_d, N_a$$의 설정 문제는 performance와 complexity의 trade-off 문제를 겪을 수 있다.\r\n    - 따라서 $$N_a = N_d$$가 가장 이상적인 choice이다.\r\n  - $$\\gamma$$는 Tabnet의 hyperparameter에서 높은 성능을 낼 수 있는 중요한 역할\r\n    - 대부분 larger $$N_{steps}$$를 사용하면 larger $$\\gamma$$를 사용해야한다.\r\n  - larger batch size를 사용하는 것이 이득이다.\r\n  - large learning rate를 쓰는 것이 중요하다.\r\n    - 어차피 decay될 것\r\n\r\n---\r\n\r\n# 평가\r\n\r\n- tabular data를 처리할 수 있는 딥러닝\r\n- unsupervised 방식도 가능함\r\n\r\n---\r\n\r\n## 참고 자료\r\n\r\n- 논문: [TabNet: Attentive Interpretable Tabular Learning](https://arxiv.org/abs/1908.07442)\r\n- GitHub: [TabNet](https://github.com/dreamquark-ai/tabnet)\r\n"},{"excerpt":"","fields":{"slug":"/BOJ_1764/"},"frontmatter":{"date":"June 08, 2021","title":"[백준] 1764_듣보잡","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 1764번: 듣보잡\r\n# https://www.acmicpc.net/problem/1764\r\n# 메모리/시간: 41748KB / 128ms\r\n\r\nimport sys\r\n\r\ninput = sys.stdin.readline\r\n\r\nN, M = map(int, input().rstrip().split())\r\n\r\ndont_hear = set()\r\ndont_see = set()\r\n\r\nfor _ in range(N):\r\n    dont_hear.add(input().rstrip())\r\n\r\nfor _ in range(M):\r\n    dont_see.add(input().rstrip())\r\n\r\nanswer = sorted(list(dont_hear.intersection(dont_see)))\r\n\r\nprint(len(answer))\r\nprint(\"\\n\".join(answer))\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_20291/"},"frontmatter":{"date":"June 08, 2021","title":"[백준] 20291_파일 정리","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 20291번: 파일 정리\r\n# https://www.acmicpc.net/problem/20291\r\n# 메모리/시간: 42992KB / 244ms\r\n\r\nimport sys\r\n\r\ninput = sys.stdin.readline\r\n\r\nN = int(input())\r\n\r\nextension = dict()\r\n\r\nfor _ in range(N):\r\n    ext = input().rstrip().split(\".\")[1]\r\n    if ext not in extension.keys():\r\n        extension[ext] = 1\r\n    else:\r\n        extension[ext] += 1\r\n\r\nanswer = sorted(extension.items(), key=lambda x: x[0])\r\nfor x in answer:\r\n    k, v = x\r\n    print(f\"{k} {v}\")\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_16171/"},"frontmatter":{"date":"June 07, 2021","title":"[백준] 16171_나는 친구가 적다 (Small)","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 16171번: 나는 친구가 적다 (Small)\r\n# https://www.acmicpc.net/problem/16171\r\n# 메모리/시간: 29200KB / 68ms\r\n\r\nimport sys\r\n\r\ninput = sys.stdin.readline\r\n\r\nS = list(input().rstrip())\r\nK = input().rstrip()\r\nnew = [s if s.isalpha() else \"\" for s in S]\r\n\r\nprint(1) if K in \"\".join(new) else print(0)\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_9342/"},"frontmatter":{"date":"June 07, 2021","title":"[백준] 9342_염색체","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 9342번: 염색체\r\n# https://www.acmicpc.net/problem/9342\r\n# 메모리/시간: 32084KB / 92ms\r\n\r\nimport sys\r\nfrom collections import deque\r\n\r\ninput = sys.stdin.readline\r\n\r\nT = int(input())\r\nfor _ in range(T):\r\n    _input = deque(input().rstrip() + \" \")\r\n    cond1, cond2, cond3, cond4, cond5 = True, False, False, False, False\r\n    \r\n    if _input[0] not in \"ABCDEF\":\r\n        cond1 = False\r\n    if _input[0] != \"A\":\r\n        _input.popleft()\r\n    if cond1:\r\n        while _input[0] == \"A\":\r\n            _input.popleft()\r\n            cond2 = True\r\n        if cond2:\r\n            while _input[0] == \"F\":\r\n                _input.popleft()\r\n                cond3 = True\r\n            if cond3:\r\n                while _input[0] == \"C\":\r\n                    _input.popleft()\r\n                    cond4 = True\r\n                if cond4:\r\n                    cnt = 0\r\n                    cond5_ = False\r\n                    for x in _input:\r\n                        if x == \" \":\r\n                            cond5_ = True\r\n                            continue\r\n                        if x in \"ABCDEF\":\r\n                            cnt += 1\r\n                            cond5_ = True\r\n                        else:\r\n                            break\r\n                    if cond5_ and (0 <= cnt <= 1):\r\n                        cond5 = True\r\n\r\n    print(\"Infected!\") if all([cond1, cond2, cond3, cond4, cond5]) else print(\"Good\")\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_1181/"},"frontmatter":{"date":"June 04, 2021","title":"[백준] 1181_단어 정렬","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 1181번: 단어 정렬\r\n# https://www.acmicpc.net/problem/1181\r\n# 메모리/시간: 36680KB / 124ms\r\n\r\nimport sys\r\n\r\ninput = sys.stdin.readline\r\n\r\nN = int(input().rstrip())\r\n_input = set([input().rstrip() for _ in range(N)])\r\n_input_len = [len(x) for x in _input]\r\nword_list = [[x, y] for x, y in zip(_input, _input_len)]\r\nword_list.sort(key=lambda x: (x[1], x[0]))\r\n\r\nfor x in word_list:\r\n    print(x[0])\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_4659/"},"frontmatter":{"date":"June 04, 2021","title":"[백준] 4659_비밀번호 발음하기","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 4659번: 비밀번호 발음하기\r\n# https://www.acmicpc.net/problem/4659\r\n# 메모리/시간: 32108KB / 88ms\r\n\r\nimport sys\r\nfrom collections import deque\r\n\r\ninput = sys.stdin.readline\r\n\r\naeiou = ('a', 'e', 'i', 'o', 'u')\r\n\r\nwhile True:\r\n    _input = input().rstrip()\r\n    if _input == \"end\":\r\n        break\r\n    password = deque(_input)\r\n    cond1, cond2, cond3 = False, True, True\r\n    ck_cond2, ck_cond3 = [], \"\"\r\n    \r\n    while password:\r\n        x = password.popleft()\r\n        if not cond1:\r\n            if x in aeiou:\r\n                cond1 = True\r\n\r\n        if cond2:\r\n            if x in aeiou:\r\n                if len(ck_cond2) == 0:\r\n                    ck_cond2 = [x]\r\n                else:\r\n                    if ck_cond2[0] in aeiou:\r\n                        ck_cond2.append(x)\r\n                    else:\r\n                        ck_cond2 = [x]\r\n\r\n            else:\r\n                if len(ck_cond2) == 0:\r\n                    ck_cond2 = [x]\r\n                else:\r\n                    if ck_cond2[0] in aeiou:\r\n                        ck_cond2 = [x]\r\n                    else:\r\n                        ck_cond2.append(x)\r\n\r\n            if len(ck_cond2) >= 3:\r\n                cond2 = False\r\n\r\n        if cond3:\r\n            if x == ck_cond3:\r\n                if (x == 'e') or (x == 'o'):\r\n                    continue\r\n                else:\r\n                    cond3 = False\r\n\r\n            else:\r\n                ck_cond3 = x\r\n\r\n    print(f\"<{_input}> is acceptable.\") if all([cond1, cond2, cond3]) else print(f\"<{_input}> is not acceptable.\")\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_10798/"},"frontmatter":{"date":"June 03, 2021","title":"[백준] 10798_세로읽기","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 10798번: 세로읽기\r\n# https://www.acmicpc.net/problem/10798\r\n# 메모리/시간: 29200KB / 68ms\r\n\r\nimport sys\r\n\r\ninput = sys.stdin.readline\r\n\r\n_input = [list(map(str, input().rstrip())) for _ in range(5)]\r\n\r\n_max = 0\r\n\r\nfor i in range(5):\r\n    if len(_input[i]) > _max:\r\n        _max = len(_input[i])\r\n\r\nanswer = \"\"\r\n\r\nfor j in range(_max):\r\n    for i in range(5):\r\n        try:\r\n            answer += _input[i][j]\r\n        except:\r\n            continue\r\n\r\nprint(answer)\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_1316/"},"frontmatter":{"date":"June 03, 2021","title":"[백준] 1316_그룹 단어 체커","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 1316번: 그룹 단어 체커\r\n# https://www.acmicpc.net/problem/1316\r\n# 메모리/시간: 31864KB / 96ms\r\n\r\nimport sys\r\nfrom collections import deque\r\n\r\ninput = sys.stdin.readline\r\n\r\nN = int(input())\r\n\r\ncnt = 0\r\nfor _ in range(N):\r\n    _input = deque([x for x in input().rstrip()])\r\n    str_len = len(_input)\r\n    ck = set()\r\n    tmp = \"\"\r\n    while _input:\r\n        x = _input.popleft()\r\n        if x not in ck:\r\n            ck.add(x)\r\n            tmp = x\r\n            str_len -= 1\r\n        else:\r\n            if x == tmp:\r\n                str_len -= 1\r\n            else:\r\n                break\r\n    if str_len == 0:\r\n        cnt += 1\r\n\r\nprint(cnt)\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_6550/"},"frontmatter":{"date":"June 03, 2021","title":"[백준] 6550_부분 문자열","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 6550번: 부분 문자열\r\n# https://www.acmicpc.net/problem/6550\r\n# 메모리/시간: 32064KB / 120ms\r\n\r\nimport sys\r\nfrom collections import deque\r\n\r\ninput = sys.stdin.readline\r\n\r\nwhile True:\r\n    _input = input().rstrip()\r\n    if len(_input) == 0:\r\n        break\r\n    s, t = _input.split()\r\n    s, t = deque(s), deque(t)\r\n    cond = False\r\n    while t:\r\n        if len(s) == 0:\r\n            cond = True\r\n            break\r\n        x = t.popleft()\r\n        if x == s[0]:\r\n            s.popleft()\r\n    if len(s) == 0:\r\n        cond = True\r\n    print(\"Yes\") if cond else print(\"No\")\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_20154/"},"frontmatter":{"date":"June 02, 2021","title":"[백준] 20154_이 구역의 승자는 누구야?!","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 20154번: 이 구역의 승자는 누구야?!\r\n# https://www.acmicpc.net/problem/20154\r\n# 메모리/시간: 49600KB / 552ms\r\n\r\nimport sys\r\nfrom collections import deque\r\n\r\ninput = sys.stdin.readline\r\n\r\nalphabet = {'A': 3, 'B': 2, 'C': 1, 'D': 2, 'E': 3, 'F': 3, 'G': 3, 'H': 3, 'I': 1, 'J': 1, 'K': 3, 'L': 1, 'M': 3, 'N': 3, 'O': 1, 'P': 2, 'Q': 2, 'R': 2, 'S': 1, 'T': 2, 'U': 1, 'V': 1, 'W': 2, 'X': 2, 'Y': 2, 'Z': 1}\r\n\r\n_input = [alphabet[x] for x in list(map(str, input().rstrip()))]\r\nqueue = deque(_input)\r\n\r\nwhile len(queue) > 1:\r\n    _tmp = deque()\r\n    for _ in range(len(queue) // 2):\r\n        a = queue.popleft()\r\n        b = queue.popleft()\r\n        _tmp.append((a + b) % 10)\r\n    if len(queue) % 2 != 0:\r\n        _tmp.append(queue.popleft())\r\n    queue = _tmp\r\n\r\nprint(\"I'm a winner!\") if queue.popleft() % 2 == 1 else print(\"You're the winner?\")\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_11365/"},"frontmatter":{"date":"June 01, 2021","title":"[백준] 11365_!밀비 급일","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 11365번: !밀비 급일\r\n# https://www.acmicpc.net/problem/11365\r\n# 메모리/시간: 29200KB / 64ms\r\n\r\nimport sys\r\n\r\ninput = sys.stdin.readline\r\n\r\nwhile True:\r\n    _input = input().rstrip()\r\n    if _input == \"END\":\r\n        break\r\n    print(_input[::-1])\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_9046/"},"frontmatter":{"date":"June 01, 2021","title":"[백준] 9046_복호화","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 9046번: 복호화\r\n# https://www.acmicpc.net/problem/9046\r\n# 메모리/시간: 31864KB / 96ms\r\n\r\nimport sys\r\nfrom collections import Counter\r\n\r\ninput = sys.stdin.readline\r\n\r\nT = int(input())\r\ntest_case = [list(map(str, input().rstrip())) for _ in range(T)]\r\n\r\nfor i in range(T):\r\n    tmp = Counter(test_case[i])\r\n    tmp -= Counter({\" \": tmp[\" \"]})\r\n    cnt = 0\r\n    answer = \"\"\r\n    for k, v in tmp.items():\r\n        if v == max(tmp.values()):\r\n            cnt += 1\r\n            answer = k\r\n    if cnt == 1:\r\n        print(answer)\r\n    else:\r\n        print(\"?\")\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_11720/"},"frontmatter":{"date":"May 31, 2021","title":"[백준] 11720_숫자의 합","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 11720번: 숫자의 합\r\n# https://www.acmicpc.net/problem/11720\r\n# 메모리/시간: 29200KB / 76ms\r\n\r\nimport sys\r\n\r\ninput = sys.stdin.readline\r\n\r\nN = int(input().rstrip())\r\nnumber = str(input().rstrip())\r\n_sum = 0\r\n\r\nfor x in number:\r\n    _sum += int(x)\r\n\r\nprint(_sum)\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_3029/"},"frontmatter":{"date":"May 31, 2021","title":"[백준] 3029_경고","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 3029번: 경고\r\n# https://www.acmicpc.net/problem/3029\r\n# 메모리/시간: 31864KB / 96ms\r\n\r\nimport sys\r\n\r\ninput = sys.stdin.readline\r\n\r\nnow_hour, now_min, now_sec = map(int, input().split(\":\"))\r\nna_hour, na_min, na_sec = map(int, input().split(\":\"))\r\n\r\nnow = now_hour*60*60 + now_min*60 + now_sec\r\nna = na_hour*60*60 + na_min*60 + na_sec\r\n\r\ntime = (na - now) if (na > now) else (24*60*60 - now + na)\r\n\r\nhour = time // (60*60)\r\ntime -= hour*60*60\r\nmin = time // 60\r\ntime -= min*60\r\nsec = time\r\n\r\nprint(f\"{hour:02}:{min:02}:{sec:02}\")\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_13023/"},"frontmatter":{"date":"May 23, 2021","title":"[백준] 13023_ABCDE","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 13023번: ABCDE\r\n# https://www.acmicpc.net/problem/13023\r\n# 메모리/시간: 29452KB / 3328ms\r\n\r\nimport sys\r\n\r\ninput = sys.stdin.readline\r\n\r\nN, M = map(int, input().split())\r\n\r\ngraph = [[] for _ in range(N)]\r\nvisited = [False] * N\r\n\r\nfor _ in range(M):\r\n    a, b = map(int, input().split())\r\n    graph[a].append(b)\r\n    graph[b].append(a)\r\n\r\ndef dfs(v, cnt):\r\n    global answer\r\n    visited[v] = True\r\n    if cnt >= 4:\r\n        answer = True\r\n        return None\r\n    for x in graph[v]:\r\n        if not visited[x]:\r\n            dfs(x, cnt+1)\r\n            visited[x] = False\r\n\r\nanswer = False\r\nfor v in range(N):\r\n    dfs(v, 0)\r\n    visited[v] = False\r\n    if answer:\r\n        break\r\n\r\nprint(int(answer))\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_16954/"},"frontmatter":{"date":"May 23, 2021","title":"[백준] 16954_움직이는 미로 탈출","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 16954번: 움직이는 미로 탈출\r\n# https://www.acmicpc.net/problem/16954\r\n# 메모리/시간: 33048KB / 96ms\r\n\r\nimport sys\r\nfrom collections import deque\r\n\r\ninput = sys.stdin.readline\r\n\r\n_map = [list(input().rstrip()) for _ in range(8)]\r\n\r\n\r\ndirection = ((0, 0), (1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (1, -1), (-1, 1), (-1, -1))\r\n\r\ndef bfs(xxx, yyy):\r\n    queue = deque()\r\n    queue.append((xxx, yyy))\r\n    while queue:\r\n        wall = wall_pos()\r\n        if len(wall) == 0:\r\n            return 1\r\n        pos_cnd = set()\r\n        for _ in range(len(queue)):\r\n            pos = queue.popleft()\r\n            x, y = pos\r\n            for d in direction:\r\n                dx, dy = d\r\n                xx, yy = x + dx, y + dy\r\n                if (xx < 0) or (xx >= 8) or (yy < 0) or (yy >= 8) or ((xx, yy) in wall):\r\n                    continue\r\n                if (xx, yy) == (0, 7):\r\n                    return 1\r\n                pos_cnd.add((xx, yy))\r\n        new_wall = wall_move(wall)\r\n        if len(pos_cnd) == 0:\r\n            return 0\r\n        else:\r\n            remain = pos_cnd - new_wall\r\n            if len(remain) == 0:\r\n                return 0\r\n            else:\r\n                for xy in remain:\r\n                    queue.append(xy)\r\n    return 0\r\n\r\ndef wall_pos():\r\n    global _map\r\n    wall = set()\r\n    for i in range(8):\r\n        for j in range(8):\r\n            if _map[i][j] == \"#\":\r\n                wall.add((i, j))\r\n    return wall\r\n\r\ndef wall_move(wall):\r\n    global _map\r\n    new_wall = set()\r\n    for pos in wall:\r\n        x, y = pos\r\n        if 0 <= x < 7:\r\n            _map[x+1][y] = \"#\"\r\n            new_wall.add((x+1, y))\r\n    remain = wall - new_wall\r\n    for pos in remain:\r\n        x, y = pos\r\n        _map[x][y] = \".\"\r\n    return new_wall\r\n\r\nprint(bfs(7, 0))\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_18513/"},"frontmatter":{"date":"May 22, 2021","title":"[백준] 18513_샘터","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 18513번: 샘터\r\n# https://www.acmicpc.net/problem/18513\r\n# 메모리/시간: 50788KB / 300ms\r\n\r\nimport sys\r\nfrom collections import deque\r\n\r\ninput = sys.stdin.readline\r\n\r\nN, K = map(int, input().split())\r\n\r\n_sam = list(map(int, input().split()))\r\n\r\ndx = [-1, 1]\r\n\r\ndef bfs(_sam):\r\n    global K\r\n    queue = deque(_sam)\r\n    visited = set()\r\n    for x in _sam:\r\n        visited.add(x)\r\n    unhappiness = 0\r\n    answer = 0\r\n    while queue:\r\n        unhappiness += 1\r\n        if unhappiness > 100000000:\r\n            return None\r\n        for _ in range(len(queue)):\r\n            x = queue.popleft()\r\n            for way in range(2):\r\n                if K == 0:\r\n                    return answer\r\n                xx = x + dx[way]\r\n                if (xx <= -200000000) or (xx >= 200000000) or (xx in visited):\r\n                    continue\r\n                if xx not in visited:\r\n                    K -= 1\r\n                    answer += unhappiness\r\n                    queue.append(xx)\r\n                    visited.add(xx)\r\n\r\nprint(bfs(_sam))\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_2668/"},"frontmatter":{"date":"May 22, 2021","title":"[백준] 2668_숫자고르기","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 2668번: 숫자고르기\r\n# https://www.acmicpc.net/problem/2668\r\n# 메모리/시간: 29200KB / 76ms\r\n\r\nimport sys\r\n\r\ninput = sys.stdin.readline\r\n\r\nN = int(input())\r\n\r\nrow = [0 for _ in range(N+1)]\r\n\r\nfor i in range(1, N+1):\r\n    row[i] = int(input())\r\n\r\ndef dfs(v, i):\r\n    visited[v] = True\r\n    x = row[v]\r\n    if not visited[x]:\r\n        dfs(x, i)\r\n    elif visited[x] and (x == i):\r\n        result.append(x)\r\n\r\nresult = []\r\n\r\nfor i in range(1, N+1):\r\n    visited = [False for _ in range(N+1)]\r\n    dfs(i, i)\r\n\r\nprint(len(result))\r\nprint(\"\\n\".join(map(str, result)))\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_14940/"},"frontmatter":{"date":"May 21, 2021","title":"[백준] 14940_쉬운 최단거리","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 14940번: 쉬운 최단거리\r\n# https://www.acmicpc.net/problem/14940\r\n# 메모리/시간: 183080KB / 508ms (PyPy3)\r\n\r\nimport sys\r\nfrom collections import deque\r\n\r\ninput = sys.stdin.readline\r\n\r\nN, M = map(int, input().split())\r\n\r\n_map = [list(map(int, input().rstrip().split())) for _ in range(N)]\r\noutput_map = [[0] * M for _ in range(N)]\r\n\r\ndx, dy = [1, 0, -1, 0], [0, 1, 0, -1]\r\n\r\ndef bfs(pos):\r\n    queue = deque()\r\n    queue.append(pos)\r\n    visited = set()\r\n    visited.add(pos)\r\n    while queue:\r\n        x, y = queue.popleft()\r\n        for way in range(4):\r\n            xx, yy = x + dx[way], y + dy[way]\r\n            if (xx < 0) or (xx >= N) or (yy < 0) or (yy >= M) or ((xx, yy) in visited):\r\n                continue\r\n            if _map[xx][yy] == 0:\r\n                continue\r\n            if _map[xx][yy] == 1:\r\n                output_map[xx][yy] = output_map[x][y] + 1\r\n                queue.append([xx, yy])\r\n                visited.add((xx, yy))\r\n    return output_map, visited\r\n\r\ndef where_is_2():\r\n    for i in range(N):\r\n        for j in range(M):\r\n            if _map[i][j] == 2:\r\n                return (i, j)\r\n\r\ndef not_zero():\r\n    c = set()\r\n    for i in range(N):\r\n        for j in range(M):\r\n            if _map[i][j] != 0:\r\n                c.add((i, j))\r\n    return c\r\n\r\ndef cant_go(pos_set):\r\n    for pos in pos_set:\r\n        x, y = pos\r\n        output_map[x][y] = -1\r\n    return output_map\r\n\r\npos = where_is_2()\r\nnz = not_zero()\r\noutput_map, ck = bfs(pos)\r\nremain = nz - ck\r\nif len(remain) != 0:\r\n    output_map = cant_go(remain)\r\n\r\nfor x in output_map:\r\n    print(\" \".join(map(str, x)))\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_16973/"},"frontmatter":{"date":"May 21, 2021","title":"[백준] 16973_직사각형 탈출","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 16973번: 직사각형 탈출\r\n# https://www.acmicpc.net/problem/16973\r\n# 메모리/시간: 152336KB / 864ms\r\n\r\nimport sys\r\nfrom collections import deque\r\n\r\ninput = sys.stdin.readline\r\n\r\nN, M = map(int, input().split())\r\n\r\n_map = [list(map(int, input().rstrip().split())) for _ in range(N)]\r\n\r\nH, W, S_r, S_c, F_r, F_c = map(int, input().split())\r\n\r\nS_r, S_c, F_r, F_c = S_r-1, S_c-1, F_r-1, F_c-1\r\n\r\ndx, dy = [1, 0, -1, 0], [0, 1, 0, -1]\r\n\r\ndef bfs(x, y):\r\n    _map[x][y] = -1\r\n    queue = deque([[x, y]])\r\n    # visited = [[x, y]]\r\n    cnt = 0\r\n    while queue:\r\n        for _ in range(len(queue)):\r\n            x, y = queue.popleft()\r\n            if [x, y] == [F_r, F_c]:\r\n                return cnt\r\n            for way in range(4):\r\n                xx, yy = x + dx[way], y + dy[way]\r\n                if (xx < 0) or (xx+H-1 >= N) or (yy < 0) or (yy+W-1 >= M) or (_map[xx][yy] == -1):\r\n                # if (xx < 0) or (xx+H-1 >= N) or (yy < 0) or (yy+W-1 >= M) or ([xx, yy] in visited):\r\n                    continue\r\n                else:\r\n                    if not_wall(xx, yy, way):\r\n                        _map[xx][yy] = -1\r\n                        queue.append([xx, yy])\r\n                        # visited.append([xx, yy])\r\n        cnt += 1\r\n    return -1\r\n\r\ndef not_wall(x, y, way):\r\n    if way == 0:\r\n        for z in range(y, y+W):\r\n            if _map[x+H-1][z] == 1:\r\n                return False\r\n    elif way == 1:\r\n        for z in range(x, x+H):\r\n            if _map[z][y+W-1] == 1:\r\n                return False\r\n    elif way == 2:\r\n        for z in range(y, y+W):\r\n            if _map[x][z] == 1:\r\n                return False\r\n    else:\r\n        for z in range(x, x+H):\r\n            if _map[z][y] == 1:\r\n                return False\r\n    return True\r\n\r\nprint(bfs(S_r, S_c))\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_13549/"},"frontmatter":{"date":"May 16, 2021","title":"[백준] 13549_숨바꼭질 3","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 13549번: 숨바꼭질 3\r\n# https://www.acmicpc.net/problem/13549\r\n# 메모리/시간: 131664KB / 6368ms (PyPy3)\r\n\r\nimport sys\r\nfrom collections import deque\r\n\r\ninput = sys.stdin.readline\r\n\r\nN, K = map(int, input().split())\r\n\r\nf1 = lambda x: x-1\r\nf2 = lambda x: x+1\r\nf3 = lambda x: 2*x\r\nfunc = [f3, f1, f2]\r\n\r\ndef check(x, cnt):\r\n    for i, f in enumerate(func):\r\n        xx = f(x)\r\n        find = []\r\n        if (xx < 0) or (xx > 100000):\r\n            continue\r\n        if xx not in visited:\r\n            visited.append(xx)\r\n            if xx == K:\r\n                find.append(True)\r\n                if i == 0:\r\n                    return any(find), cnt\r\n                else:\r\n                    return any(find), cnt + 1\r\n            else:\r\n                find.append(False)\r\n                if i == 0:\r\n                    queue.append([xx, cnt])\r\n                else:\r\n                    queue.append([xx, cnt+1])\r\n    return any(find), cnt\r\n\r\ndef bfs(X):\r\n    while queue:\r\n        for _ in range(len(queue)):\r\n            x, cnt = queue.popleft()\r\n            if x == K:\r\n                return cnt\r\n            cond, tmp = check(x, cnt)\r\n            if cond:\r\n                return tmp\r\n\r\ncnt = 0\r\nqueue = deque([[N, cnt]])\r\nvisited = [N]\r\nprint(bfs(N))\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_2636/"},"frontmatter":{"date":"May 16, 2021","title":"[백준] 2636_치즈","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 2636번: 치즈\r\n# https://www.acmicpc.net/problem/2636\r\n# 메모리/시간: 36160KB / 188ms\r\n\r\nimport sys\r\nfrom collections import deque\r\n\r\nsys.setrecursionlimit(10**6)\r\ninput = sys.stdin.readline\r\n\r\nR, C = map(int, input().split())\r\n\r\n_map = [list(map(int, input().rstrip().split())) for _ in range(R)]\r\n\r\ndx, dy = [1, 0, -1, 0], [0, 1, 0, -1]\r\n\r\ndef to_melt(pos_set):\r\n    queue = deque(pos_set)\r\n    while queue:\r\n        x, y = queue.popleft()\r\n        for way in range(4):\r\n            xx, yy = x + dx[way], y + dy[way]\r\n            if(xx < 0) or (xx >= R) or (yy < 0) or (yy >= C):\r\n                continue\r\n            if _map[xx][yy] == 1:\r\n                _map[xx][yy] = 0\r\n\r\ndef dfs(x, y):\r\n    cluster.add((x, y))\r\n    for way in range(4):\r\n        xx, yy = x + dx[way], y + dy[way]\r\n        if (xx < 0) or (xx >= R) or (yy < 0) or (yy >= C):\r\n            continue\r\n        if (xx, yy) in cluster:\r\n            continue\r\n        if _map[xx][yy] == 0:\r\n            dfs(xx, yy)\r\n\r\ndef cheese_count():\r\n    cnt = 0\r\n    for i in range(R):\r\n        for j in range(C):\r\n            if _map[i][j] == 1:\r\n                cnt += 1\r\n    return cnt\r\n\r\nmelt_time = 0\r\n\r\nwhile True:\r\n    cluster = set()\r\n    dfs(0, 0)\r\n    if len(cluster) == R*C:\r\n        break\r\n    cnt = cheese_count()\r\n    melt_time += 1\r\n    to_melt(cluster)\r\n\r\nprint(melt_time)\r\nprint(cnt)\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_14502/"},"frontmatter":{"date":"May 15, 2021","title":"[백준] 14502_연구소","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 14502번: 연구소\r\n# https://www.acmicpc.net/problem/14502\r\n# 메모리/시간: 34080KB / 4388ms\r\n\r\nimport sys\r\nfrom collections import deque\r\nfrom itertools import combinations\r\nfrom copy import deepcopy\r\n\r\ninput = sys.stdin.readline\r\n\r\nN, M = map(int, input().split())\r\n\r\n_map = [list(map(int, input().rstrip().split())) for _ in range(N)]\r\n\r\ndx, dy = [1, 0, -1, 0], [0, 1, 0, -1]\r\n\r\ndef virus_bfs(_map, pos):\r\n    queue = deque(pos)\r\n    while queue:\r\n        for _ in range(len(queue)):\r\n            x, y = queue.popleft()\r\n            for way in range(4):\r\n                xx, yy = x + dx[way], y + dy[way]\r\n\r\n                if (xx < 0) or (xx >= N) or (yy < 0) or (yy >= M):\r\n                    continue\r\n\r\n                if _map[xx][yy] == 0:\r\n                    _map[xx][yy] = 2\r\n                    queue.append([xx, yy])\r\n\r\ndef virus():\r\n    pos = []\r\n    for i in range(N):\r\n        for j in range(M):\r\n            if _map[i][j] == 2:\r\n                pos.append([i, j])\r\n    return pos\r\n\r\ndef empty():\r\n    pos = []\r\n    for i in range(N):\r\n        for j in range(M):\r\n            if _map[i][j] == 0:\r\n                pos.append([i, j])\r\n    return pos\r\n\r\ndef not_virus(_map):\r\n    cnt = 0\r\n    for i in range(N):\r\n        for j in range(M):\r\n            if _map[i][j] == 0:\r\n                cnt += 1\r\n    return cnt\r\n\r\nvirus_space = virus()\r\nempty_space = empty()\r\nempty_C_3 = list(combinations(empty_space, 3))\r\n\r\nanswer = 0\r\n\r\nfor c1, c2, c3 in empty_C_3:\r\n    tmp_map = deepcopy(_map)\r\n    x1, y1 = c1\r\n    x2, y2 = c2\r\n    x3, y3 = c3\r\n    tmp_map[x1][y1] = 1\r\n    tmp_map[x2][y2] = 1\r\n    tmp_map[x3][y3] = 1\r\n    virus_bfs(tmp_map, virus_space)\r\n    cnt = not_virus(tmp_map)\r\n    if cnt > answer:\r\n        answer = cnt\r\n\r\nprint(answer)\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_16918/"},"frontmatter":{"date":"May 14, 2021","title":"[백준] 16918_봄버맨","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 16918번: 봄버맨\r\n# https://www.acmicpc.net/problem/16918\r\n# 메모리/시간: 35008KB / 3668ms\r\n\r\nimport sys\r\nfrom collections import deque\r\n\r\ninput = sys.stdin.readline\r\n\r\nR, C, N = map(int, input().split())\r\n\r\n_map = [list(map(str, input().rstrip())) for _ in range(R)]\r\n\r\ndx, dy = [1, 0, -1, 0], [0, 1, 0, -1]\r\n\r\ndef boom(pos):\r\n    queue = deque(pos)\r\n    while queue:\r\n        for _ in range(len(queue)):\r\n            x, y = queue.popleft()\r\n            for way in range(4):\r\n                xx, yy = x + dx[way], y + dy[way]\r\n\r\n                if(xx < 0) or (xx >= R) or (yy < 0) or (yy >= C):\r\n                    continue\r\n\r\n                if _map[xx][yy] == \"O\":\r\n                    _map[xx][yy] = \".\"\r\n\r\n            _map[x][y] = \".\"\r\n\r\ndef bomb(_map):\r\n    pos = []\r\n    for i in range(R):\r\n        for j in range(C):\r\n            if _map[i][j] == \"O\":\r\n                pos.append([i, j])\r\n    return pos\r\n\r\nfor i in range(1, N):\r\n    if i % 2 == 0:\r\n        boom(pos)\r\n    else:\r\n        pos = bomb(_map)\r\n        _map = [[\"O\" for _ in range(C)] for _ in range(R)]\r\n\r\nif N % 2 == 0:\r\n    _map = [[\"O\" for _ in range(C)] for _ in range(R)]\r\n\r\nfor row in _map:\r\n    print(\"\".join(map(str, row)))\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_7576/"},"frontmatter":{"date":"May 13, 2021","title":"[백준] 7576_토마토","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 7576번: 토마토\r\n# https://www.acmicpc.net/problem/7576\r\n# 메모리/시간: 162360KB / 2524ms\r\n\r\nimport sys\r\nfrom collections import deque\r\n\r\ninput = sys.stdin.readline\r\n\r\nM, N = map(int, input().split())\r\n\r\n_map = [list(map(int, input().rstrip().split())) for _ in range(N)]\r\n\r\ndx, dy = [1, 0, -1, 0], [0, 1, 0, -1]\r\n\r\ndef bfs(pos):\r\n    queue = deque(pos)\r\n    day = -1\r\n    while queue:\r\n        for _ in range(len(queue)):\r\n            x, y = queue.popleft()\r\n            for way in range(4):\r\n                xx, yy = x + dx[way], y + dy[way]\r\n\r\n                if (xx < 0) or (xx >= N) or (yy < 0) or (yy >= M):\r\n                    continue\r\n\r\n                if _map[xx][yy] == 0:\r\n                    _map[xx][yy] = 1\r\n                    queue.append([xx, yy])\r\n\r\n        day += 1\r\n    return day\r\n\r\ndef check_all():\r\n    for i in range(N):\r\n        for j in range(M):\r\n            if _map[i][j] == 0:\r\n                return False\r\n    return True\r\n\r\npos = []\r\nfor i in range(N):\r\n    for j in range(M):\r\n        if _map[i][j] == 1:\r\n            pos.append([i, j])\r\n\r\nday = bfs(pos)\r\n\r\nif not check_all():\r\n    day = -1\r\n\r\nprint(day)\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_7569/"},"frontmatter":{"date":"May 13, 2021","title":"[백준] 7569_토마토","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 7569번: 토마토\r\n# https://www.acmicpc.net/problem/7569\r\n# 메모리/시간: 52264KB / 3484ms\r\n\r\nimport sys\r\nfrom collections import deque\r\n\r\ninput = sys.stdin.readline\r\n\r\nM, N, H = map(int, input().split())\r\n\r\n_map = [[list(map(int, input().rstrip().split())) for _ in range(N)] for _ in range(H)]\r\n\r\ndz, dx, dy = [1, 0, 0, -1, 0, 0], [0, 1, 0, 0, -1, 0], [0, 0, 1, 0, 0, -1]\r\n\r\ndef bfs(pos):\r\n    queue = deque(pos)\r\n    day = -1\r\n    while queue:\r\n        for _ in range(len(queue)):\r\n            z, x, y = queue.popleft()\r\n            for way in range(6):\r\n                zz, xx, yy = z + dz[way], x + dx[way], y + dy[way]\r\n\r\n                if (zz < 0) or (zz >= H) or (xx < 0) or (xx >= N) or (yy < 0) or (yy >= M):\r\n                    continue\r\n\r\n                if _map[zz][xx][yy] == 0:\r\n                    _map[zz][xx][yy] = 1\r\n                    queue.append([zz, xx, yy])\r\n\r\n        day += 1\r\n    return day\r\n\r\ndef check_all():\r\n    for i in range(N):\r\n        for j in range(M):\r\n            for k in range(H):\r\n                if _map[k][i][j] == 0:\r\n                    return False\r\n    return True\r\n\r\npos = []\r\nfor i in range(N):\r\n    for j in range(M):\r\n        for k in range(H):\r\n            if _map[k][i][j] == 1:\r\n                pos.append([k, i, j])\r\n\r\nday = bfs(pos)\r\n\r\nif not check_all():\r\n    day = -1\r\n\r\nprint(day)\r\n```"},{"excerpt":"Transformer-DST 1. Key Idea 이전 논문들에서는 Encoder에서 BERT를 사용하지만, Value Generation부분에서는 RNN Decoder를 사용하는 아이러니.. Purely Transformer-based…","fields":{"slug":"/Transformer-DST/"},"frontmatter":{"date":"May 12, 2021","title":"Jointly Optimizing State Operation Prediction and Value Generation for Dialogue State Tracking","tags":["Paper Review","DST","Dialogue State Tracking","Transformer-DST"]},"rawMarkdownBody":"\r\n## Transformer-DST\r\n\r\n## 1. Key Idea\r\n\r\n- 이전 논문들에서는 Encoder에서 BERT를 사용하지만, Value Generation부분에서는 RNN Decoder를 사용하는 아이러니..\r\n- Purely Transformer-based framework를 사용\r\n즉, Single BERT가 **Encoder와 Decoder 모두**에서 work\r\n→ 이렇게 하면 prediction objective와 value generation objective가 BERT 하나만 optimize하게 됨\r\n- Encoder(BERT)에서 사용한 hidden states 값을 Decoder(BERT)에서 Re-use가 가능해짐\r\n\r\n## 2. Input\r\n\r\n- Input으로는 SOM-DST와 같은 구조를 지님\r\n- 아래 그림과 같이 **D1, D2, S1을 INPUT**으로 넣고, **OUTPUT으로 S2**를 출력\r\n\r\n<img src=\"input.PNG\" height=150>\r\n\r\n- $$D_{t-1}, D_{t}, S_{t-1}$$을 INPUT으로 $$S_{t}$$를 PREDICT\r\n- $$D_{t}$$ : t번째 dialogue turn의 (System utterance, User response) pair\r\n- $$S_{t}$$ : $$(d_{j}, s_{j}, v_{j}) | 1<=j<=J$$\r\n\r\n여기서 $$d$$는 domain, $$s$$는 slot, $$v$$는 value를 나타냄\r\n\r\n만약, 아무 정보도 없을시 $$(d_{j}, s_{j})$$로 나타내고, $$v_{j}$$는 NULL\r\n\r\n## 3. Overview\r\n\r\n- 왼쪽은 Transformer Encoder, 오른쪽은 Transformer Decoder\r\n- Encoder (왼쪽)에서 $$h_{sl}^{L}$$ (hidden state)를 뽑아내고, Decoder (오른쪽)에서 Re-use하는 방법으로 사용됨\r\n- Decoder (오른쪽)은 left-to-right attention (왼쪽에서 오른쪽으로 차례로 출력하는 language model, 즉 왼쪽 출력값이 오른쪽 입력)\r\n\r\n<img src=\"overview.PNG\">\r\n\r\n## 4. Encoder\r\n\r\n<img src=\"encoder.PNG\">\r\n\r\n- Encoder의 Input은 $$D_{t-1}, D_{t}, S_{t-1}$$ 3가지가 들어감\r\n    - $$D_{t}$$는 t번째 turn의 ( System Utterance, User Resposne ) pair\r\n    - $$S_{t-1}$$은 $$(d_{j}, s_{j}, v_{j}) | 1<= j <= J$$\r\n\r\n### 4-1) Encoder Input\r\n\r\n<img src=\"encoder_input.PNG\">\r\n\r\n- $$[SLOT] \\bigoplus d_{j} \\bigoplus - \\bigoplus s_{j} \\bigoplus - \\bigoplus v_{j}$$ 으로 구성\r\n    - $$\\bigoplus$$는 concat을 나타냄\r\n    - 총 $$J$$개의 domain-slot에 대해서 만들어줌\r\n    - $$[SLOT] \\bigoplus d_{j} \\bigoplus - \\bigoplus s_{j} \\bigoplus - \\bigoplus v_{j}$$  * J번\r\n- $$[SLOT]$$은 Transformer block을 통과한 후, $$X^{l}_{sl_{j}}$$ 형태로 출력되며, Prediction (CARRYOVER, ..., UPDATE 등)으로 사용됨\r\n\r\n### 4-2) Multi-head self-attention\r\n\r\n<img src=\"multi-head.png\">\r\n\r\n- Multi-head Self-attention 매카니즘 사용\r\n\r\n<img src=\"multi-head2.png\">\r\n\r\n- 여기서 $$M^{x}$$ : self-attention mask matrix\r\n    - $$M^{x} \\in R^{|x| \\times |x|}$$\r\n    - $$M^{x}_{ij} \\in \\{0, - \\infty \\}$$\r\n    - $$M^{x}_{ij} = 0$$이면 i-th position이 j-th position에 attend하다는 의미\r\n    - $$M^{x}_{ij} = -\\infty$$이면 i-th position과 j-th position을 prevents하겠다는 의미\r\n\r\n### 4-3) Encoder Output\r\n\r\n$$X^{L} = [x^{L}_{cls}, x^{L}_{1}, ..., x^L_{sl_{1}}, ..., x^{L}_{sl_{J}},...]$$\r\n\r\n### 4-4) Encoder Objective\r\n\r\n- Encoder outputs $$x^{L}_{sl_{j}}$$에서 $$[SLOT]$$칸에 해당하는 값을 확인\r\n- CARRYOVER, DELETE, DONTCARE, UPDATE\r\n- UPDATE의 경우에만 decoder generater에서 사용함\r\n\r\n## 5. Decoder (Slot Value Generation)\r\n\r\n<img src=\"decoder.PNG\">\r\n\r\n- Left-to-right self-attention을 사용함\r\n- Encoder에서 도출해낸 hidden states를 decoder에서 reuse\r\n- Resue의 의미는 hidden state를 decoder에서 다시 한번 계산할 필요가 없어진다는 의미를 갖음.\r\n\r\n### 5-1) Decoder Input\r\n\r\n<img src=\"decoder_input.PNG\">\r\n\r\n- Encoder (reuse)\r\n    - 왼쪽의 $$D_{t}$$와 $$[SLOT]$$은 Encoder 부분을 나타냄\r\n    - 현재 turn의 $$D_{t}$$의 hidden state vector를 사용함\r\n    - $$[SLOT]$$ 중 UPDATE로 prediction이 된 hidden state vector만 사용함\r\n- Decoder\r\n    - $$[BOS]$$는 String의 시작\r\n    - $$w^{v_{j}}_1, w^{v_{j}}_2$$는 decoder의 output을 다시 input으로 가지고 와서 사용 (left-to-right self-attention)\r\n\r\n### 5-2) Left-to-right self-attention\r\n\r\n<img src=\"left-to-right.png\">\r\n\r\n<img src=\"left-to-right2.png\">\r\n\r\n- 일반 Multi-head attention하고 비슷\r\n- $$\\hat{X}$$ : re-used된 encoder hidden states\r\n- $$Y$$ : Decoder hidden states\r\n- $$\\hat{X}$$와 $$Y$$를 concat해서 사용\r\n- 만약 $$j \\leq i$$일때,  $$M^{y}_{ij} = 0$$ 으로 사용 (left-to-right attention)\r\n\r\n### 5-3) Decoder Objective\r\n\r\n- **Generated slot value loss**와 **ground-truth slot value**를 비교해서  Loss를 산출\r\n- Teacher Forcing을 모든 time에서 사용\r\n\r\n# 결과\r\n\r\n- MutliWOZ 2.0과 MultiWOZ 2.1에서 제출 당시 SOTA\r\n\r\n<img src=\"result.png\">\r\n\r\n- 각각의 Domain의 Joint goal Accuracy를 비교\r\n    - 신기한 점은 Taxi 빼고 (다른 모델보다) 높은 성능을 보임\r\n    - 이유를 찾아보니 Taxi의 경우 Train과의 co-occurrence relations가 있음\r\n    - 하지만 Ours에는 이러한 점을 해결하려고 하지는 않았음\r\n\r\n<img src=\"result2.png\">\r\n\r\n- 시간의 경우 SOM-DST보다는 Inference time이 오래걸림\r\n\r\n<img src=\"result3.png\">\r\n\r\n- Reuse를 사용했을 경우에도 여러가지 방법을 시도해보았고, $$D_{t} + [SLOT]$$을 사용했을 때 Joint Accuracy에서 좋은 성능을 보였음\r\n\r\n<img src=\"result4.png\">\r\n\r\n---\r\n\r\n## 참고 자료\r\n\r\n- 논문: [Jointly Optimizing State Operation Prediction and Value Generation for Dialogue State Tracking](https://arxiv.org/abs/2010.14061)\r\n- GitHub: [Transformer-DST](https://github.com/zengyan-97/Transformer-DST)\r\n"},{"excerpt":"","fields":{"slug":"/BOJ_2178/"},"frontmatter":{"date":"May 12, 2021","title":"[백준] 2178_미로 탐색","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 2178번: 미로 탐색\r\n# https://www.acmicpc.net/problem/2178\r\n# 메모리/시간: 31780KB / 104ms\r\n\r\nimport sys\r\nfrom collections import deque\r\n\r\ninput = sys.stdin.readline\r\n\r\nN, M = map(int, input().split())\r\n\r\n_map = [list(map(int, input().rstrip())) for _ in range(N)]\r\n\r\ndx, dy = [1, 0, -1, 0], [0, 1, 0, -1]\r\n\r\ndef bfs(x, y):\r\n    queue = deque()\r\n    queue.append([x, y])\r\n\r\n    while queue:\r\n        x, y = queue.popleft()\r\n        for way in range(4):\r\n            xx, yy = x + dx[way], y + dy[way]\r\n\r\n            if (xx < 0) or (xx >= N) or (yy < 0) or (yy >= M):\r\n                continue\r\n\r\n            if _map[xx][yy] == 0:\r\n                continue\r\n\r\n            if _map[xx][yy] == 1:\r\n                _map[xx][yy] = _map[x][y] + 1\r\n                queue.append([xx, yy])\r\n    \r\n    return _map[N-1][M-1]\r\n\r\nprint(bfs(0, 0))\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_2667/"},"frontmatter":{"date":"May 12, 2021","title":"[백준] 2667_단지번호붙이기","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 2667번: 단지번호붙이기\r\n# https://www.acmicpc.net/problem/2667\r\n# 메모리/시간: 29136KB / 68ms\r\n\r\nimport sys\r\n\r\ninput = sys.stdin.readline\r\n\r\nN = int(input())\r\n\r\n_map = [list(map(int, input().rstrip())) for _ in range(N)]\r\n\r\ndx, dy = [1, 0, -1, 0], [0, 1, 0, -1]\r\n\r\ndef dfs(x, y, cluster):\r\n    if (x < 0) or (x >= N) or (y < 0) or (y >= N):\r\n        return False\r\n    \r\n    if _map[x][y] == 1:\r\n        cluster.append([x, y])\r\n        _map[x][y] = 0\r\n\r\n        for way in range(4):\r\n            xx, yy = x + dx[way], y + dy[way]\r\n            dfs(xx, yy, cluster)\r\n\r\n        return True\r\n\r\n    return False\r\n\r\ncnt = 0\r\nnum_cluster = []\r\n\r\nfor i in range(N):\r\n    for j in range(N):\r\n        cluster = []\r\n\r\n        if dfs(i, j, cluster) == True:\r\n            cnt += 1\r\n            num_cluster.append(len(cluster))\r\n\r\nprint(cnt)\r\nnum_cluster.sort()\r\nprint(\"\\n\".join(map(str, num_cluster)))\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_11725/"},"frontmatter":{"date":"May 11, 2021","title":"[백준] 11725_트리의 부모 찾기","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 11725번: 트리의 부모 찾기\r\n# https://www.acmicpc.net/problem/11725\r\n# 메모리/시간: 132484KB / 404ms\r\n\r\nimport sys\r\n\r\nsys.setrecursionlimit(10**6)\r\ninput = sys.stdin.readline\r\n\r\ndef dfs(start, parent):\r\n    for i in tree[start]:\r\n        if parent[i]==0:\r\n            parent[i] = start\r\n            dfs(i, parent)\r\n\r\nN = int(input())\r\n\r\ntree = [[] for _ in range(N+1)]\r\n\r\nfor _ in range(N-1):\r\n    start, end = map(int, input().split())\r\n    tree[start].append(end)\r\n    tree[end].append(start)\r\n\r\nparent = [0 for _ in range(N+1)]\r\n\r\ndfs(1, parent)\r\n\r\nfor i in range(2, N+1):\r\n    print(parent[i])\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_1325/"},"frontmatter":{"date":"May 11, 2021","title":"[백준] 1325_효율적인 해킹","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 1325번: 효율적인 해킹\r\n# https://www.acmicpc.net/problem/1325\r\n# 메모리/시간: 224112KB / 12148ms (PyPy3)\r\n\r\nimport sys\r\nfrom collections import deque\r\n\r\ninput = sys.stdin.readline\r\n\r\ndef bfs(start, visited):\r\n    queue = deque([start])\r\n    visited[start] = True\r\n    cnt = 0\r\n    while queue:\r\n        v = queue.popleft()\r\n        cnt += 1\r\n        for i in graph[v]:\r\n            if not visited[i]:\r\n                queue.append(i)\r\n                visited[i] = True\r\n    return cnt\r\n\r\nN, M = map(int, input().split())\r\n\r\ngraph = [[] for _ in range(N+1)]\r\n\r\nfor _ in range(M):\r\n    A, B = map(int, input().split())\r\n    graph[B].append(A)\r\n\r\nmax_cnt = 0\r\nanswer = []\r\n\r\nfor i in range(1, N+1):\r\n    visited = [False for _ in range(N+1)]\r\n    cnt = bfs(i, visited)\r\n    if cnt == max_cnt:\r\n        answer.append(i)\r\n    elif cnt >= max_cnt:\r\n        max_cnt = cnt\r\n        answer = [i]\r\n\r\nprint(\" \".join(map(str, answer)))\r\n```"},{"excerpt":"SOM-DST SOM-DST 기존 모델의 문제점 Ontology-based DST 실제 시나리오에 잘 대응하지 못함 unseen value를 처리할 수 없음 ontology가 많으면 처리 시간이 오래 걸림 Open-vocab-based DST…","fields":{"slug":"/SOM-DST/"},"frontmatter":{"date":"May 10, 2021","title":"Efficient Dialogue State Tracking by Selectively Overwriting Memory","tags":["Paper Review","DST","Dialogue State Tracking","SOM-DST"]},"rawMarkdownBody":"\r\n## SOM-DST\r\n\r\n![SOM-DST](https://github.com/clovaai/som-dst/raw/master/img/overview6.png)\r\n\r\n## 기존 모델의 문제점\r\n\r\n### Ontology-based DST\r\n\r\n- 실제 시나리오에 잘 대응하지 못함\r\n- unseen value를 처리할 수 없음\r\n- ontology가 많으면 처리 시간이 오래 걸림\r\n\r\n### Open-vocab-based DST (TRADE)\r\n\r\n- turn마다 slot의 모든 value를 생성해야해서 비효율적임\r\n\r\n---\r\n\r\n## Definition\r\n\r\n$$t$$: turn\r\n\r\n$$S^j$$: slot\r\n\r\n$$V^j_t$$: corresponding slot value\r\n\r\n$$J$$: total number of such slots\r\n\r\n$$r^j_t\\in O = \\left\\{\\rm\\textbf{CARRYOVER, DELETE, DONTCARE, UPDATE}\\right\\}$$\r\n\r\n$$A_t$$: System response\r\n\r\n$$U_t$$: User utterance\r\n\r\n---\r\n\r\n## State Operation Predictor (Encoder)\r\n\r\nEncoder 모델로 **pretrained BERT encoder** 사용\r\n\r\n### <span style=\"background-color:#fcffb0\">Encoder Input을 만들기 위한 준비물</span>\r\n\r\n$$D_t = A_t ⊕ ; ⊕ U_t ⊕ [SEP]$$: dialogue utterances at turn t\r\n\r\n- `;` $A_t$와 $U_t$를 구분하기 위한 스페셜 토큰\r\n- `[SEP]` dialogue turn이 끝났다는 것을 표시하기 위한 스페셜 토큰\r\n\r\n$$B_t^j = [SLOT]^j ⊕ S^j ⊕ - ⊕ V_t^j$$ : representation of the j-th slot-value pair\r\n\r\n- j-th slot-value pair를 하나의 벡터로 aggregate\r\n- $$`[SLOT]^j`$$\r\n\r\n    [SLOT] 이라는 스페셜 토큰을 사용\r\n\r\n    BERT의 [CLS] 토큰과 같은 역할\r\n\r\n- $$`V_t^j`$$\r\n\r\n    <img src=\"V_t^j.PNG\" height=150>\r\n\r\n$$B_t = B_t^1 ⊕ ... ⊕ B_t^J$$ : representation of the dialogue state at turn t\r\n\r\n### Encoder Input\r\n```\r\n$$X_t = [CLS] ⊕ D_{t-1} ⊕D_t ⊕ B_{t-1}$$\r\n\r\nsegment id:        0       1         1\r\n```\r\n⇒ **Input : Sum($X_t$ embedding, segment id embedding, positional embedding)**\r\n\r\ndialogue history로 이전 턴의 dialogue utterances $$D_{t-1}$$을 사용한다.\r\ndialogue history의 size: 1\r\n\r\n모델이 입력으로 들어오는 dialogue 간의 `Markov property`를 가정\r\n\r\n이전 turn dialogue state $$B_{t-1}$$은 전체 dialogue history를 압축적으로 표현하는 역할\r\n\r\n### Encoder Output\r\n\r\n$$H_t \\in \\mathbb R^{\\left|X_t\\right|\\times d}$$ : $$h_t^{\\rm X}$$ $$(t=1...t)$$ 까지 집합\r\n\r\n$$h_t^{[CLS]}, h_t^{[SLOT]^j} \\in \\mathrm R^d$$\r\n\r\n- $$[CLS], [SLOT]^j$$에 대응하는 output\r\n\r\n$$h_t^X = tanh(W_{pool} h_t^{[CLS]})$$\r\n\r\n- $$h_t^X$$: 전체 input $$X_t$$를 sequence로 aggregate\r\n- $$W_{pool} \\in \\mathbb R^{d\\times d}$$: feed-forward layer with a learnable parameter\r\n\r\n### State Operation Prediction\r\n\r\n$$P^j_{opr, t} = softmax(W_{opr} h_t^{[SLOT]^j})$$\r\n\r\n- $$W_{opr} \\in \\mathbb R^{\\left| O\\right|\\times d}$$ : learnable parameter\r\n- $$P_{opr, t}^j \\in \\mathbb R^{\\left| O\\right|}$$ : j-th slot의 turn t에서의 연산에 대한 확률 분포\r\n- SOM-DST에서는 $$\\left| O\\right| = 4$$,\r\n\r\n    $$O = \\left\\{\\rm{CARRYOVER, DELETE, DONTCARE, UPDATE}\\right\\}$$\r\n\r\n→ $$r_t^j = argmax(P_{opr, t}^j)$$\r\n\r\n→ slot의 Operation의 결과가 `UPDATE` 일 때 slot value를 generation\r\n\r\n- Encoder에서 나온 Operation의 결과가 `Update`인 경우를 집합으로 표현하면\r\n\r\n    $$\\mathbb{U}_t = \\left\\{j|r_t^j = \\rm{UPDATE}\\right\\}$$, and its size as $$J_t^\\prime = \\left| \\mathbb{U}_t\\right|$$\r\n\r\n    Recab for V\r\n\r\n    <img src=\"V_t^j.PNG\" height=150>\r\n\r\n---\r\n\r\n## Slot Value Generator (Decoder)\r\n\r\n- Encoder에서 나온 Operation의 결과가 `Update` 인 경우 해당 slot의 value를 예측\r\n- SOM-DST의 generator는 value를 $$J$$개가 아닌 $$J^\\prime_t$$개의 slot에 대해서만 만들어준다.\r\n\r\n    대부분의 경우에서 $$J^\\prime_t \\ll J$$이기 때문에 더 효율적이라고 주장\r\n\r\n- Decoder 모델로 **GRU** 사용\r\n    - 입력으로 word embedding vector $$e_t^{j,k}$$를 받으면서 **GRU**의 hidden state vector $$g_t^{j, k}$$를 recurrent하게 업데이트\r\n    - $$g_t^{j, 0} = h_t^{\\rm x}$$, $$e_t^{j,0} = h_t^{[slot]j}$$: **GRU**에 들어가는 초기값\r\n    - $$g_t^{j, k} = GRU(g_t^{j, k-1}, e_t^{j,k})$$\r\n    - $$e_t^{j,k}$$가 [EOS] 토큰이 나올때까지 진행\r\n    - hidden state $$g_t^{j, k}$$는 k-th decoding step을 거치면서 vocabulary 와 user utterance의 단어에 대한 확률 분포로 변함\r\n\r\n        $$P^{j, k}_{vcb, t} = softmax(Eg^{j, k}_t) \\in \\mathbb R^{d_{vcb}}$$\r\n\r\n        - $$E \\in \\mathbb R^{d_{vcb}\\times d}$$: Encoder와 Decoder가 서로 공유하는 word embedding matrix\r\n            - $$d_{vcb}$$: vocabulary size\r\n\r\n        $$P^{j, k}_{ctx, t} = softmax(H_t g_t^{j, k}) \\in \\mathbb R^{\\left|X_t\\right|}$$\r\n\r\n        - user utterance의 단어에 대한 확률 분포\r\n\r\n        $$P^{j, k}_{val, t} = \\alpha P^{j, k}_{vcb, t} + (1-\\alpha) P^{j, k}_{ctx, t}$$: final output distribution\r\n\r\n        - $$\\alpha = sigmoid(W_1 \\left[g^{j, k}_t ; e^{j, k}_t ; c^{j, k}_t\\right])$$\r\n            - $$W_1 \\in \\mathbb R^{1\\times (3d)}$$: learnable parameter\r\n            - $$c^{j, k}_t = P^{j, k}_{ctx, t} H_t \\in \\mathbb R^d$$: context vector\r\n\r\n---\r\n\r\n## Objective Function\r\n\r\n### State operation predictor\r\n\r\n**Main Task**\r\n\r\nstate operation classification\r\n\r\n**Auxiliary Task**\r\n\r\ndomain classification\r\n\r\nstate operation classification 외에도 domain classification을 보조 task로 사용하여 모델이 dialogue turn 간의 slot operation과 domain transition의 상관 관계를 학습하도록 함\r\n\r\n$$P_{dom, t} = softmax(W_{dom} h_t^{\\rm X})$$\r\n\r\n- $$W_{dom} \\in \\mathbb R^{d_{dom}\\times d}$$: learnable parameter\r\n- $$P_{dom, t} \\in \\mathbb R^{d_{dom}}$$: turn t에서 domain에 대한 확률 분포\r\n    - $$d_{dom}$$: # of domains defined in the dataset\r\n\r\n**Average of the negative log-likelihood**\r\n\r\n$$L_{opr, t} = -\\frac{1}{J}\\sum_{j=1}^{J}(Y_{opr, t}^j)^\\top log(P^j_{opr, t})$$\r\n\r\n$$L_{dom, t} = -(Y_{dom, t})^\\top log(P_{dom, t})$$\r\n\r\n- $$Y_{dom, t} \\in \\mathbb R^{d_{dom}}$$: one-hot vector for the ground truth domain\r\n- $$Y^j_{opr, t} \\in \\mathbb R^{\\left| O\\right|}$$: one-hot vector for the ground truth operation for the j-th slot\r\n\r\n### Slot value generator\r\n\r\n**Average of the negative log-likelihood**\r\n\r\n$$L_{svg, t} = -\\frac{1}{\\left|\\mathbb U_t\\right|}\\sum_{j\\in\\mathbb U_t}^{}\\left[\\frac{1}{K^j_t}\\sum_{k=1}^{K^j_t}(Y_{val, t}^{j, k})^{\\top}log(P^{j, k}_{val, t})\\right]$$\r\n\r\n- $$K_t^j$$: # of tokens of the ground truth value that needs to be generated for the j-th slot\r\n- $$Y_{val, t}^{j, k} \\in \\mathbb R^{d_{vcb}}$$: one-hot vector for the ground truth token that needs to be generated for the j-th slot at the k-th decoding step\r\n\r\n### Final Loss\r\n\r\nto minimized $$L_{joint, t} = L_{opr, t} + L_{dom, t} + L_{svg, t}$$\r\n\r\n---\r\n\r\n## Experimental Setup\r\n\r\n### Datasets\r\n\r\nMultiWOZ 2.0 and MultiWOZ 2.1\r\n\r\n### Training\r\n\r\n- Encoder : Bert-base-uncased\r\n- Decoder : GRU\r\n- Hidden size : 768\r\n- Optimizer : BertAdam\r\n- Encoder LR and warmup : 4e-5, 0.1\r\n- Decoder LR and warmup : 1e-4, 0.1\r\n- Batch size : 32\r\n- Dropout : 0.1\r\n- Word Dropout 적용, 0.1확률로 word 를 [UNK] 로 바꿈\r\n- Input max length : 256\r\n- Training Epoch : 30\r\n\r\n---\r\n\r\n## 결과\r\n\r\n### Joint Goal Accuracy\r\n\r\n<img src=\"joint_goal_accuracy.PNG\" height=400>\r\n\r\n> † indicates the case where BERT-large is used for our model\r\n\r\n### Domain-specific Accuracy\r\n\r\n<img src=\"domain-specific_accuracy.PNG\" height=450>\r\n\r\n### Latency\r\n\r\n<img src=\"latency.PNG\" height=150>\r\n\r\n---\r\n\r\n## 평가\r\n\r\n- JGA, Domain-specific Accuracy 에서 SOTA 혹은 비슷한 수준의 성능을 보여줌\r\n- inferecnce 타임이 매우 짧음에도 불구하고 좋은 성능을 보여줌\r\n\r\n---\r\n\r\n## 참고 자료\r\n\r\n- 논문: [Efficient Dialogue State Tracking by Selectively Overwriting Memory](https://arxiv.org/abs/1911.03906)\r\n- 영상: [[Paper Review] SOM-DST : Efficient Dialogue State Tracking by Selectively Overwriting Memory - KoreaUniv DSBA](https://www.youtube.com/watch?v=7Nwe2BBUZsw)\r\n- GitHub: [SOM-DST](https://github.com/clovaai/som-dst)\r\n"},{"excerpt":"","fields":{"slug":"/BOJ_1260/"},"frontmatter":{"date":"May 10, 2021","title":"[백준] 1260_DFS와 BFS","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 1260번: DFS와 BFS\r\n# https://www.acmicpc.net/problem/1260\r\n# 메모리/시간: 32984KB / 104ms\r\n\r\nimport sys\r\nfrom collections import deque\r\n\r\ninput = sys.stdin.readline\r\n\r\ndef dfs(v, visited):\r\n    visited[v] = True\r\n    print(v, end=' ')\r\n    for i in graph[v]:\r\n        if not visited[i]:\r\n            dfs(i, visited)\r\n\r\ndef bfs(start, visited):\r\n    queue = deque([start])\r\n    visited[start] = True\r\n    while queue:\r\n        v = queue.popleft()\r\n        print(v, end=' ')\r\n        for i in graph[v]:\r\n            if not visited[i]:\r\n                queue.append(i)\r\n                visited[i] = True\r\n\r\nN, M, V = map(int, input().split())\r\n\r\ngraph = [[] for _ in range(N+1)]\r\n\r\nfor _ in range(M):\r\n    start, end = map(int, input().split())\r\n    graph[start].append(end)\r\n    graph[end].append(start)\r\n\r\nfor i, x in enumerate(graph):\r\n    x.sort()\r\n\r\ndfs_visited = [False for _ in range(N+1)]\r\nbfs_visited = [False for _ in range(N+1)]\r\n\r\ndd = dfs(V, dfs_visited)\r\nprint()\r\nbb = bfs(V, bfs_visited)\r\n```"},{"excerpt":"","fields":{"slug":"/BOJ_2606/"},"frontmatter":{"date":"May 10, 2021","title":"[백준] 2606_바이러스","tags":["BOJ","Problem-Solving"]},"rawMarkdownBody":"\r\n```python\r\n###### 2606번: 바이러스\r\n# https://www.acmicpc.net/problem/2606\r\n# 메모리/시간: 28776KB / 68ms\r\n\r\nimport sys\r\n\r\ninput = sys.stdin.readline\r\n\r\ndef dfs(v, visited):\r\n    visited[v] = True\r\n    for i in graph[v]:\r\n        if not visited[i]:\r\n            dfs(i, visited)\r\n    return visited\r\n\r\nN = int(input())\r\nL = int(input())\r\n\r\ngraph = [[] for _ in range(N+1)]\r\n\r\nfor _ in range(L):\r\n    start, end = map(int, input().split())\r\n    graph[start].append(end)\r\n    graph[end].append(start)\r\n\r\nvisited = [False for _ in range(N+1)]\r\nanswer = sum(dfs(1, visited)) - 1\r\nprint(answer)\r\n```"},{"excerpt":"CHAN-DST slot imbalance 문제를 해결하고자 adaptive objective를 도입 a contextual hierarchical attention network (CHAN)를 사용: dislogue history에서 relevant…","fields":{"slug":"/CHAN-DST/"},"frontmatter":{"date":"May 07, 2021","title":"A Contextual Hierarchical Attention Network with Adaptive Objective for Dialogue State Tracking","tags":["Paper Review","DST","Dialogue State Tracking","CHAN-DST"]},"rawMarkdownBody":"\r\n## CHAN-DST\r\n\r\n- slot imbalance 문제를 해결하고자 adaptive objective를 도입\r\n- a contextual hierarchical attention network (CHAN)를 사용: dislogue history에서 relevant context를 찾기 위함  \r\n  → 각 턴의 발화로부터 word-level 관련 정보 검색  \r\n  → contextual representation으로 encode  \r\n  → 모든 context표현을 turn-level관련 정보로 집계한 후 word-level 정보와 합친 output 생성  \r\n- state transition prediction task\r\n\r\n---\r\n\r\n## Definition\r\n\r\n- $$T$$: turn\r\n- $$U_t$$: user utterance of turn t\r\n- $$R_t$$: system response of turn t\r\n- $$X$$: $$\\left\\{(U_1, R_1), ... , (U_T, R_T)\\right\\}$$\r\n- $$B_t$$: $$\\left\\{(s, v_t), s \\in S\\right\\}$$\r\n- $$S$$: set of slots\r\n- $$v_t$$: corresponding value of the slot $$s$$\r\n- slot: concatenation of a domain name and a slot name\r\n\r\n---\r\n\r\n## Contextual Hierarchical Attention Network\r\n\r\n<img src=\"structure.png\">\r\n\r\n### 1. Sentence Encoder\r\n\r\n<img src=\"sentence_encoder.png\">\r\n\r\n`utterance encoder`\r\n\r\n- BERT special token 사용  \r\n  → [CLS] : 문장의 representation들을 합치기위해 사용 (to aggregate the whole representation of a sentence)  \r\n  → [SEP] : 문장의 끝을 나타내기위해 사용.  \r\n- $$U_t = \\left\\{w_1^u, ..., w_l^u\\right\\}$$ (user utterance)  \r\n  $$R_t = \\left\\{w_1^r, ..., w_{l'}^r\\right\\}$$ (system response)  \r\n  $$t$$: dialogue turn  \r\n- $$h_t = BERT_{finetune}([R_t;U_t])$$  \r\n  ($$h_t$$: contextual word representations)  \r\n- 여기서 BERT finetune은 training도중 finetuning이 될것을 의미.\r\n\r\n`slot-value encoder`\r\n\r\n- $$BERT_{fixed}$$는 contextual semantics vectors로 encode해준다.\r\n- utterance encode할때와 다른 점은 [CLS] 토큰의 output vector를 전체 문장 representation할때 사용한다. (to obtain the whole sentence representation)\r\n- $$h_s = BERT_{fixed}(s)$$  \r\n  $$h_t^v = BERT_{fixed}(v_t)$$  \r\n- $$BERT_{fixed}$$는 training 도중 고정되어있다. 그래서 우리 모델은 unseen slots and values에 대해서 original BERT representation로 확장해서 보는게 가능하다.\r\n\r\n### 2. Slot-Word Attention\r\n\r\n<img src=\"slot-word_attention.png\">\r\n\r\n- slot-word attention은 multi-head attention을 사용한다.\r\n- $$c_{s,t}^{word} = MultiHead(h^s, h_t, h_t)$$\r\n\r\n### 3. Context Encoder\r\n\r\n<img src=\"context_encoder.png\">\r\n\r\n- context encoder : unidirectional transformer encoder\r\n- {1, ..., t} 턴에서 추출 된 word-level slot-related 정보의 contextual relevance를 모델링하기 위한 것.\r\n- $$N$$개의 idenctical한 layer가 있다.\r\n  - 각 layer는 2개의 sub-layer를 가지고 있다.\r\n  - 첫번째 sub-layer: masked multi-head self-attention(Q = K = V)\r\n  - 두번째 sub-layer: position-wise fully connected feed-forward network(FFN) (two linear transformations, RELU activation으로 구성)\r\n  - $$FFN(x) = max(0, xW_1 + b_1)W_2 + b_2$$\r\n- $$m^n = FFN(MultiHead(m^{n-1}, m^{n-1}, m^{n-1}))$$  \r\n  $$m^0 = [c_{s,1}^{word} + PE(1), ..., c_{s,t}^{word} + PE(t)]$$  \r\n  $$c_{s,\\leq t}^{ctx} = m^N$$  \r\n- $$m^n$$: n번째 context encoder레이어의 아웃풋\r\n  $$PE(.)$$: positional encoding function\r\n\r\n### 4. Slot-Turn Attention\r\n\r\n<img src=\"slot-turn_attention.png\">\r\n\r\n- turn-level relevant information을 contextual representation에서 검출해내기 위해 사용\r\n- $$c_{s,t}^{turn} = MultiHead(h^s, c_{s,\\leq t}^{ctx},c_{s,\\leq t}^{ctx})$$\r\n- 이로인해 word-level and turn-level 의 relevant information을 historical dialogues에서 얻어낼 수 있다.\r\n\r\n### 5. Global-Local Fusion Gate\r\n\r\n<img src=\"global-local-fusion_gate.png\">\r\n\r\n- global context와 local utterance의 균형을 맞추기 위해, contextual information과 current turn information의 비율을 조절함.\r\n- $$c_{s,t}^{word},~~ c_{s,t}^{turn}$$에 따라 global과 local정보가 어떻게 결합되어야할지 알려주는 fusion gate mechanism을 사용\r\n- $$g_{s,t} = \\sigma(W_g\\bigodot[c_{s,t}^{word};c_{s,t}^{turn}])$$\r\n- $$c_{s,t}^gate = g_{s,t}\\bigotimes c_{s,t}^{word} + (1-g_{s,t}\\bigotimes c_{s,t}^{turn})$$\r\n  - $$W_g \\in R^{2d\\times d}$$\r\n  - $$\\sigma$$: Sigmoid\r\n  - $$\\bigodot$$, $$\\bigotimes$$\r\n- $$o_{s,t}$$ = LayerNorm(Linear(Dropout($c_{s,t}^{gate}$)))\r\n- **value $$v_t$$에 대한 확률분포와 training objective**  \r\n  $$p(v_t|U_{\\leq t},~R_{\\leq t}, s) = exp(-||o_{s,t} - h_t^v||2)\\over {\\sum{v'\\in V_s}exp(-||o_{s,t}-h_t^{v'}||2)}$$  \r\n  *$$L{dst}$$* $$= \\sum_{s\\in S}\\sum ^T_{t = 1}-log(p(\\hat v_t|U_{\\leq t},~R_{\\leq t}, s))$$  \r\n  - $$V_s$$: candidate value set of slot s\r\n  - $$\\hat v_t \\in V_s$$: ground-truth value of slot s\r\n\r\n---\r\n\r\n## State Transition Prediction\r\n\r\n<img src=\"state_transition_prediction.png\">\r\n\r\n- relevant context를 더 잘 포착하기 위해, auxiliary binary classification task사용.\r\n- $$c_{s,t}^{stp} = tanh(W_c \\odot c_{s,t}^{gate})$$\r\n- $$p_{s,t}^{stp} = \\sigma (W_p \\odot [c_{s,t}^{stp};c_{s, t-1}^{stp}])$$\r\n  - $$W_c \\in \\R^{d\\times d}$$\r\n  - $$W_c \\in \\R^{2d}$$\r\n  - $$t = 1$$일때는 $$c_{s,t}^{stp}$$와 zero vectors를 concat함.\r\n- binary CE loss ($$y_{s,t}^{stp}$$: ground-truth transition labels // $$p_{s,t}^{stp}$$: transition probability)\r\n- $$L_{stp} = \\sum_{s\\in S}\\sum_{t = 1}^T -y_{s,t}^{stp}~.~log(p_{s,t}^{stp})$$\r\n\r\n---\r\n\r\n## Adaptive Objective\r\n\r\n- hard slots와 samples에 관한 optimization을 encourage한다.\r\n- all slots의 learning을 balancing함.\r\n- $$acc_s^{val}$$: accuracy of slot s on validation set\r\n- `slot-level difficulty`\r\nif $$acc_s^{val} \\leq acc_{s'}^{val}$$;  \r\n  → slot s 가 slot s'보다 더 어려운 것.  \r\n  → $$\\alpha$$: slot-level difficulty  \r\n  - $$\\alpha_s = {1 - acc_s^{val} \\over {\\sum_{s'\\in S} 1-acc_{s'}^{val}}} \\cdot |S|$$\r\n- `sample-level difficulty`  \r\n  → Suppose there are two samples $$\\left\\{(U_t, R_t),(s, v_t)\\right\\}$$ and $$\\left\\{(U_{t'}, R_{t'}),(s', v_{t'})\\right\\}$$  \r\n  → 만약 former confidence 가 latter보다 더 낮다면, 첫번째 sample이 두번째보다 더 어려운 것.  \r\n  → $$\\beta$$: sample level difficulty  \r\n  - $$\\beta(s, v_t) = (1 - p(s, v_t))^\\gamma$$\r\n  - $$p(s,v_t)$$: confidence of sample $$(U_t, R_t),(s, v_t)$$  \r\n  $$\\gamma$$: hyper-parameter\r\n- $$L_{adapt}(s,v_t) = -\\alpha_s\\beta(s, v_t)log(p(s, v_t))$$\r\n- slot s가 평균 slot의 difficulty보다 높다면, $$\\alpha_s$$는 s에 대한 loss를 키울 것이다. 비슷하게, sample의 optimization이 low confidence를 갖고 있다면 loss는 커질것이다.\r\n\r\n---\r\n\r\n### Optimization\r\n\r\n- During joint training, we optimize the sum of these two loss functions as following  \r\n  $$L_{joint} = L_{dst} + L_{stp}$$  \r\n- At the fine-tuning phase, we adopt the adaptive objective to fine-tune DST task as following  \r\n  $$L_{finetune} = \\sum_{s\\in S}\\sum^T_{t=1}L_{adapt(s, \\hat v_t)}$$  \r\n\r\n---\r\n\r\n## 참고 자료\r\n\r\n- 논문: [A Contextual Hierarchical Attention Network with Adaptive Objective for Dialogue State Tracking](https://www.aclweb.org/anthology/2020.acl-main.563.pdf)\r\n- GitHub: [CHAN-DST](https://github.com/smartyfh/CHAN-DST)\r\n"},{"excerpt":"TRADE 1. 전체 프로세스 TRADE 대화를 인코더를 통해 인코딩한다. 인코딩된 대화와 슬롯으로 를 만들고, 이를 바탕으로 와 를 생성하여 로 슬롯에 해당하는 value를 찾는다. 대화와 슬롯으로 만들어진 를 사용하여 를 만들고, 를 통해 slot…","fields":{"slug":"/TRADE/"},"frontmatter":{"date":"April 30, 2021","title":"Transferable Multi-Domain State Generator for Task-Oriented Dialogue Systems","tags":["Paper Review","DST","Dialogue State Tracking","TRADE"]},"rawMarkdownBody":"\r\n## TRADE\r\n\r\n### 1. 전체 프로세스\r\n\r\n![TRADE](https://github.com/jasonwu0731/trade-dst/raw/master/plot/model.png)\r\n\r\n1. 대화를 인코더를 통해 인코딩한다.\r\n2. 인코딩된 대화와 슬롯으로 $$h$$를 만들고, 이를 바탕으로 $$p_{value}$$와 $$p_{hist}$$를 생성하여 $$p_{final}$$로 슬롯에 해당하는 value를 찾는다.\r\n3. 대화와 슬롯으로 만들어진 $$h_{j0}$$를 사용하여 $$p_{hist}$$를 만들고, $$c_{j0}$$를 통해 slot의 value를 사용할지 결정한다.\r\n\r\n---\r\n\r\n### 2. Definition (Terminology)\r\n\r\n- $$U_{T}$$: User Utterence\r\n- $$R_{T}$$: System Response\r\n- $$X_t = \\{ (U_{t-l}, R_{t-l}), ... (U_{t}, R_{t})\\}$$:  Utterance-Response pair\r\n- $$D = \\{ D_{1}, ..., D_{N} \\}$$: Domain\r\n- $$S = \\{ S_{1}, ..., S_{M} \\}$$: Slot\r\n- $$Y^{value}_{j}$$: Value\r\n- $$B = \\{ B_{1}, ..., B_{T} \\}$$: Tuple\r\n\r\n### 3. Utterance Encoder\r\n\r\n<img src=\"utterance_encoder.png\">\r\n\r\n- 논문에서는 **Bi-directional GRU**사용 (어떤 종류의 Encoder로도 대체 가능)\r\n- Input: $$X_t = \\{ (U_{t-l}, R_{t-l}), ... (U_{t}, R_{t})\\}$$\r\n  - 슬라이딩 윈도우처럼 $$l$$값에 따라 $$t$$번째 턴에는 $$t-l$$부터 $$t$$까지의 대화쌍을 살펴봄\r\n    - 베이스라인 코드에서는 $$t$$ 턴에는 처음부터 $$t$$ 턴까지 대화를 모두 봄\r\n  - 더 구체적으로 말하자면, dialougue history 의 **모든 단어**를 **concatenation** 한 것\r\n  - $$d_{emb}$$ 차원을 지님\r\n- $$t$$ 턴까지의 대화쌍에서 토큰들의 관계를 알 수 있다.\r\n\r\n### 4. State Generator\r\n\r\n<img src=\"state_generator.png\">\r\n\r\n- Bi-directional GRU decoder 사용\r\n- $$t$$ 턴까지의 대화 인코딩 $$h_t$$에 대해 max_length(value 중 가장 토큰을 많이 가진 길이)만큼 디코더로 디코딩 진행\r\n- Copy mechanism을 통해 input dialougue의 정보를 활용하여 slot value를 generate\r\n- 처음에는 도메인-슬롯의 임베딩 sum 을 입력으로 넣어주고 이를 통해 value 의 첫 토큰이 나온다.  \r\n  다음으로는 이 토큰을 입력으로 넣어주고.. 계속하여 알맞는 value 를 뽑아낸다 (서울 + 롯데 + 호텔).  \r\n  그러다 special token 이 나오면 value 생성을 그만한다.\r\n- Pointer-Generator 방법 사용\r\n  - 위에서 생성된 $$h^{dec}_{j0}$$로 $$p_{vocab}$$(대화와 슬롯을 봤을 때 vocab 에서는 어떤 단어와 유사한지), $$p_{hist}$$(대화와 슬롯을 봤을 때 이제까지의 대화 중에서는 어떤 단어와 유사한지)를 구한다.\r\n  - **Vocab의 분포**와 **dialogue history의 분포**를 하나의 분포로 결합\r\n\r\n<img src=\"P_vocab, P_history.png\">\r\n\r\n- $$P^{vocab}_{jk}$$는 Utterence Encoder에서 나타나는 (domain, slot) $$j$$번째, $$k$$번째 value 생성 차례의 vocab 확률 분포를 나타냄\r\n  - 여기서 $$E \\in \\R^{|V| \\times d_{hdd}}$$를 나타내고, Trainable Embedding (vocab 개수 x dimension)\r\n- $$P^{history}_{jk}$$는 Utterence Encoder에서 나타나는 (domain, slot) $$j$$번째, $$k$$번째 value 생성 차례의 history 확률 분포를 나타냄\r\n  - 여기서 $$H_{t}$$는 Encode된 dialouge history를 나타냄\r\n\r\n<img src=\"P_final.png\">\r\n\r\n- $$P^{final}_{jk}$$는 $$P^{vocab}_{jk}$$, $$P^{history}_{jk}$$의 $$P^{gen}_{jk}, 1-P^{gen}_{jk}$$만큼의 확률분포를 곱해서 생성\r\n\r\n<img src=\"p_gen.png\">\r\n\r\n- $$P^{gen}_{jk}$$는 다음 원소들로 구성됨\r\n  - $$W_{1}$$: 가중치\r\n  - $$h^{dec}_{jk}$$: (domain, slot) pair와 Utterance Encoding을 가지고 만들어진 hidden state vector\r\n  - $$w_{jk}$$: word embedding\r\n  - $$c_{jk}$$: context vector\r\n  - ;는 concat을 나타냄\r\n\r\n### 5. Slot Gate\r\n\r\n<img src=\"slot_gate.png\">\r\n\r\n- Slot Generator 에서 생성된 $$h^{dec}_{j0}$$(대화와 슬롯의 관계 정보)를 통해 $$p_{history}$$를 만들고, 이를 사용해 $$c_{j0}$$(Context vecto)를 만들 수 있다. Slot Gate는 Context vector로부터 slot의 존재 여부를 알아내는 역할을 수행\r\n  - PTR, DONTCARE, NONE 3가지 label로 출력\r\n  - PTR이 나오면 value를 Generate\r\n  - DONTCARE, NONE이 나오면 Ignore\r\n\r\n<img src=\"G_j.png\">\r\n\r\nSlot gate $$G_{j}$$는 다음 원소로 구성됨\r\n\r\n- $$W_{g}$$: 가중치\r\n- $$c_{j0}$$: Context vector(first decoder Hidden state)\r\n\r\n### 6. Optimization\r\n\r\n<img src=\"optimization.png\">\r\n\r\n> 출처 : [https://www.youtube.com/watch?v=nuclwoebdEM](https://www.youtube.com/watch?v=nuclwoebdEM)\r\n\r\n- 최종 Loss는 다음으로 구성됨\r\n\r\n$$L = \\alpha L_{g} + \\beta L_{v}$$\r\n\r\n# 결과\r\n\r\n### 1. Few/Zero-shot 실험 셋팅\r\n\r\n- Target Domain을 학습 데이터에서 제외\r\n    - 나머지 Source Domain의 데이터로 학습 후, Target Domain에 대한 성능 측정\r\n- Few-Shot의 경우 Target Domain에 대한 아래 방법들로 1%의 Training data만 사용하여 학습\r\n    - Elastic Weight Consolidation (EWC)\r\n    - Gradient Episodic Memory (GEM)\r\n    - Naive Fine-tuning (Naive)\r\n\r\n<img src=\"few, zero.png\">\r\n\r\n### 2. 실험 결과\r\n\r\n<img src=\"result.png\">\r\n\r\n- **첫번째는 하나의 Domain만 제외(ex. Except Hotel)해서 훈련시킴**\r\n    - 이후, 제외시킨 Domain (ex. Hotel)의 1% data를 fine-tuning했을 때의 결과\r\n    - GEM을 사용했을 때 가장 좋은 성능이 나오는 것을 알 수 있음\r\n\r\n- **두번째는 하나의 Domain만 훈련시킨 후 (ex. Hotel) 측정하는 방법**\r\n    - Train, Taxi Domain에서 높은값들이 나오는 이유는 Domain끼리 겹치는 slot이 존재하기 때문\r\n\r\n# 평가\r\n\r\n- 새로운 domain(unseen domain)에 대해 robust한 모델\r\n- Pointer-Generator를 사용해 Open-Vocabulary 방법을 사용\r\n- turn마다 모든 슬롯 $$j$$에 대해 value를 생성하는 점이 비효율적임\r\n\r\n---\r\n\r\n## 참고 자료\r\n\r\n- 논문: [Transferable Multi-Domain State Generator for Task-Oriented Dialogue Systems](https://arxiv.org/abs/1905.08743)\r\n- 영상: [[Paper Review] Transferable Multi-Domain State Generator for Task-Oriented Dialogue Systems - KoreaUniv DSBA](https://www.youtube.com/watch?v=nuclwoebdEM)\r\n- GitHub: [TRADE](https://github.com/jasonwu0731/trade-dst)\r\n"}]}},"pageContext":{}},"staticQueryHashes":[]}